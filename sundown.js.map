{"version":3,"file":"sundown.js","sources":["src/markdown.c","src/html_blocks.h","src/stack.c","src/buffer.c","src/autolink.c","src/redcarpet_js.c","html/html.c","html/html_smartypants.c","html/houdini_html_e.c","html/houdini_href_e.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["/* markdown.c - generic markdown parser */\n\n/*\n * Copyright (c) 2009, Natacha Porté\n * Copyright (c) 2011, Vicent Marti\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"markdown.h\"\n#include \"stack.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n\n#if defined(_WIN32)\n#define strncasecmp\t_strnicmp\n#endif\n\n#define REF_TABLE_SIZE 8\n\n#define BUFFER_BLOCK 0\n#define BUFFER_SPAN 1\n\n#define MKD_LI_END 8\t/* internal list flag */\n\n#define gperf_case_strncmp(s1, s2, n) strncasecmp(s1, s2, n)\n#define GPERF_DOWNCASE 1\n#define GPERF_CASE_STRNCMP 1\n#include \"html_blocks.h\"\n\n/***************\n * LOCAL TYPES *\n ***************/\n\n/* link_ref: reference to a link */\nstruct link_ref {\n\tunsigned int id;\n\n\tstruct buf *link;\n\tstruct buf *title;\n\n\tstruct link_ref *next;\n};\n\n/* char_trigger: function pointer to render active chars */\n/*   returns the number of chars taken care of */\n/*   data is the pointer of the beginning of the span */\n/*   offset is the number of valid chars before data */\nstruct sd_markdown;\ntypedef size_t\n(*char_trigger)(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n\nstatic size_t char_emphasis(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_escape(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_autolink_url(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_autolink_www(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_superscript(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n\nenum markdown_char_t {\n\tMD_CHAR_NONE = 0,\n\tMD_CHAR_EMPHASIS,\n\tMD_CHAR_CODESPAN,\n\tMD_CHAR_LINEBREAK,\n\tMD_CHAR_LINK,\n\tMD_CHAR_LANGLE,\n\tMD_CHAR_ESCAPE,\n\tMD_CHAR_ENTITITY,\n\tMD_CHAR_AUTOLINK_URL,\n\tMD_CHAR_AUTOLINK_EMAIL,\n\tMD_CHAR_AUTOLINK_WWW,\n\tMD_CHAR_SUPERSCRIPT,\n};\n\nstatic char_trigger markdown_char_ptrs[] = {\n\tNULL,\n\t&char_emphasis,\n\t&char_codespan,\n\t&char_linebreak,\n\t&char_link,\n\t&char_langle_tag,\n\t&char_escape,\n\t&char_entity,\n\t&char_autolink_url,\n\t&char_autolink_email,\n\t&char_autolink_www,\n\t&char_superscript,\n};\n\n/* render • structure containing one particular render */\nstruct sd_markdown {\n\tstruct sd_callbacks\tcb;\n\tvoid *opaque;\n\n\tstruct link_ref *refs[REF_TABLE_SIZE];\n\tuint8_t active_char[256];\n\tstruct stack work_bufs[2];\n\tunsigned int ext_flags;\n\tsize_t max_nesting;\n\tint in_link_body;\n};\n\n/***************************\n * HELPER FUNCTIONS *\n ***************************/\n\nstatic inline struct buf *\nrndr_newbuf(struct sd_markdown *rndr, int type)\n{\n\tstatic const size_t buf_size[2] = {256, 64};\n\tstruct buf *work = NULL;\n\tstruct stack *pool = &rndr->work_bufs[type];\n\n\tif (pool->size < pool->asize &&\n\t\tpool->item[pool->size] != NULL) {\n\t\twork = pool->item[pool->size++];\n\t\twork->size = 0;\n\t} else {\n\t\twork = bufnew(buf_size[type]);\n\t\tstack_push(pool, work);\n\t}\n\n\treturn work;\n}\n\nstatic inline void\nrndr_popbuf(struct sd_markdown *rndr, int type)\n{\n\trndr->work_bufs[type].size--;\n}\n\nstatic void\nunscape_text(struct buf *ob, struct buf *src)\n{\n\tsize_t i = 0, org;\n\twhile (i < src->size) {\n\t\torg = i;\n\t\twhile (i < src->size && src->data[i] != '\\\\')\n\t\t\ti++;\n\n\t\tif (i > org)\n\t\t\tbufput(ob, src->data + org, i - org);\n\n\t\tif (i + 1 >= src->size)\n\t\t\tbreak;\n\n\t\tbufputc(ob, src->data[i + 1]);\n\t\ti += 2;\n\t}\n}\n\nstatic unsigned int\nhash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\n\treturn hash;\n}\n\nstatic struct link_ref *\nadd_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}\n\nstatic struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nfree_link_refs(struct link_ref **references)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n\t\tstruct link_ref *r = references[i];\n\t\tstruct link_ref *next;\n\n\t\twhile (r) {\n\t\t\tnext = r->next;\n\t\t\tbufrelease(r->link);\n\t\t\tbufrelease(r->title);\n\t\t\tfree(r);\n\t\t\tr = next;\n\t\t}\n\t}\n}\n\n/*\n * Check whether a char is a Markdown space.\n\n * Right now we only consider spaces the actual\n * space and a newline: tabs and carriage returns\n * are filtered out during the preprocessing phase.\n *\n * If we wanted to actually be UTF-8 compliant, we\n * should instead extract an Unicode codepoint from\n * this character and check for space properties.\n */\nstatic inline int\n_isspace(int c)\n{\n\treturn c == ' ' || c == '\\n';\n}\n\n/****************************\n * INLINE PARSING FUNCTIONS *\n ****************************/\n\n/* is_mail_autolink • looks for the address part of a mail autolink and '>' */\n/* this is less strict than the original markdown e-mail address matching */\nstatic size_t\nis_mail_autolink(uint8_t *data, size_t size)\n{\n\tsize_t i = 0, nb = 0;\n\n\t/* address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@' */\n\tfor (i = 0; i < size; ++i) {\n\t\tif (isalnum(data[i]))\n\t\t\tcontinue;\n\n\t\tswitch (data[i]) {\n\t\t\tcase '@':\n\t\t\t\tnb++;\n\n\t\t\tcase '-':\n\t\t\tcase '.':\n\t\t\tcase '_':\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn (nb == 1) ? i + 1 : 0;\n\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* tag_length • returns the length of the given tag, or 0 is it's not valid */\nstatic size_t\ntag_length(uint8_t *data, size_t size, enum mkd_autolink *autolink)\n{\n\tsize_t i, j;\n\n\t/* a valid tag can't be shorter than 3 chars */\n\tif (size < 3) return 0;\n\n\t/* begins with a '<' optionally followed by '/', followed by letter or number */\n\tif (data[0] != '<') return 0;\n\ti = (data[1] == '/') ? 2 : 1;\n\n\tif (!isalnum(data[i]))\n\t\treturn 0;\n\n\t/* scheme test */\n\t*autolink = MKDA_NOT_AUTOLINK;\n\n\t/* try to find the beginning of an URI */\n\twhile (i < size && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-'))\n\t\ti++;\n\n\tif (i > 1 && data[i] == '@') {\n\t\tif ((j = is_mail_autolink(data + i, size - i)) != 0) {\n\t\t\t*autolink = MKDA_EMAIL;\n\t\t\treturn i + j;\n\t\t}\n\t}\n\n\tif (i > 2 && data[i] == ':') {\n\t\t*autolink = MKDA_NORMAL;\n\t\ti++;\n\t}\n\n\t/* completing autolink test: no whitespace or ' or \" */\n\tif (i >= size)\n\t\t*autolink = MKDA_NOT_AUTOLINK;\n\n\telse if (*autolink) {\n\t\tj = i;\n\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == '>' || data[i] == '\\'' ||\n\t\t\t\t\tdata[i] == '\"' || data[i] == ' ' || data[i] == '\\n')\n\t\t\t\t\tbreak;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) return 0;\n\t\tif (i > j && data[i] == '>') return i + 1;\n\t\t/* one of the forbidden chars has been found */\n\t\t*autolink = MKDA_NOT_AUTOLINK;\n\t}\n\n\t/* looking for sometinhg looking like a tag end */\n\twhile (i < size && data[i] != '>') i++;\n\tif (i >= size) return 0;\n\treturn i + 1;\n}\n\n/* parse_inline • parses inline markdown elements */\nstatic void\nparse_inline(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t i = 0, end = 0;\n\tuint8_t action = 0;\n\tstruct buf work = { 0, 0, 0, 0 };\n\n\tif (rndr->work_bufs[BUFFER_SPAN].size +\n\t\trndr->work_bufs[BUFFER_BLOCK].size > rndr->max_nesting)\n\t\treturn;\n\n\twhile (i < size) {\n\t\t/* copying inactive chars into the output */\n\t\twhile (end < size && (action = rndr->active_char[data[end]]) == 0) {\n\t\t\tend++;\n\t\t}\n\n\t\tif (rndr->cb.normal_text) {\n\t\t\twork.data = data + i;\n\t\t\twork.size = end - i;\n\t\t\trndr->cb.normal_text(ob, &work, rndr->opaque);\n\t\t}\n\t\telse\n\t\t\tbufput(ob, data + i, end - i);\n\n\t\tif (end >= size) break;\n\t\ti = end;\n\n\t\tend = markdown_char_ptrs[(int)action](ob, rndr, data + i, i, size - i);\n\t\tif (!end) /* no action from the callback */\n\t\t\tend = i + 1;\n\t\telse {\n\t\t\ti += end;\n\t\t\tend = i;\n\t\t}\n\t}\n}\n\n/* find_emph_char • looks for the next emph uint8_t, skipping other constructs */\nstatic size_t\nfind_emph_char(uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 1;\n\n\twhile (i < size) {\n\t\twhile (i < size && data[i] != c && data[i] != '`' && data[i] != '[')\n\t\t\ti++;\n\n\t\tif (i == size)\n\t\t\treturn 0;\n\n\t\tif (data[i] == c)\n\t\t\treturn i;\n\n\t\t/* not counting escaped chars */\n\t\tif (i && data[i - 1] == '\\\\') {\n\t\t\ti++; continue;\n\t\t}\n\n\t\tif (data[i] == '`') {\n\t\t\tsize_t span_nb = 0, bt;\n\t\t\tsize_t tmp_i = 0;\n\n\t\t\t/* counting the number of opening backticks */\n\t\t\twhile (i < size && data[i] == '`') {\n\t\t\t\ti++; span_nb++;\n\t\t\t}\n\n\t\t\tif (i >= size) return 0;\n\n\t\t\t/* finding the matching closing sequence */\n\t\t\tbt = 0;\n\t\t\twhile (i < size && bt < span_nb) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\tif (data[i] == '`') bt++;\n\t\t\t\telse bt = 0;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i >= size) return tmp_i;\n\t\t}\n\t\t/* skipping a link */\n\t\telse if (data[i] == '[') {\n\t\t\tsize_t tmp_i = 0;\n\t\t\tuint8_t cc;\n\n\t\t\ti++;\n\t\t\twhile (i < size && data[i] != ']') {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\n'))\n\t\t\t\ti++;\n\n\t\t\tif (i >= size)\n\t\t\t\treturn tmp_i;\n\n\t\t\tswitch (data[i]) {\n\t\t\tcase '[':\n\t\t\t\tcc = ']'; break;\n\n\t\t\tcase '(':\n\t\t\t\tcc = ')'; break;\n\n\t\t\tdefault:\n\t\t\t\tif (tmp_i)\n\t\t\t\t\treturn tmp_i;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\twhile (i < size && data[i] != cc) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i >= size)\n\t\t\t\treturn tmp_i;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* parse_emph1 • parsing single emphase */\n/* closed by a symbol not preceded by whitespace and not followed by symbol */\nstatic size_t\nparse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\n\tif (!rndr->cb.emphasis) return 0;\n\n\t/* skipping one symbol if coming from emph3 */\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + 1 < size && isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* parse_emph2 • parsing single emphase */\nstatic size_t\nparse_emph2(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tint (*render_method)(struct buf *ob, const struct buf *text, void *opaque);\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\n\trender_method = (c == '~') ? rndr->cb.strikethrough : rndr->cb.double_emphasis;\n\n\tif (!render_method)\n\t\treturn 0;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\tif (i + 1 < size && data[i] == c && data[i + 1] == c && i && !_isspace(data[i - 1])) {\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = render_method(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 2 : 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}\n\n/* parse_emph3 • parsing single emphase */\n/* finds the first closing tag, and delegates to the other emph */\nstatic size_t\nparse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\t/* skip whitespace preceded symbols */\n\t\tif (data[i] != c || _isspace(data[i - 1]))\n\t\t\tcontinue;\n\n\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n\t\t\t/* triple symbol found */\n\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 3 : 0;\n\n\t\t} else if (i + 1 < size && data[i + 1] == c) {\n\t\t\t/* double symbol found, handing over to emph1 */\n\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 2;\n\n\t\t} else {\n\t\t\t/* single symbol found, handing over to emph2 */\n\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* char_emphasis • single and double emphasis parsing */\nstatic size_t\nchar_emphasis(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tuint8_t c = data[0];\n\tsize_t ret;\n\n\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\tif (offset > 0 && !_isspace(data[-1]) && data[-1] != '>')\n\t\t\treturn 0;\n\t}\n\n\tif (size > 2 && data[1] != c) {\n\t\t/* whitespace cannot follow an opening emphasis;\n\t\t * strikethrough only takes two characters '~~' */\n\t\tif (c == '~' || _isspace(data[1]) || (ret = parse_emph1(ob, rndr, data + 1, size - 1, c)) == 0)\n\t\t\treturn 0;\n\n\t\treturn ret + 1;\n\t}\n\n\tif (size > 3 && data[1] == c && data[2] != c) {\n\t\tif (_isspace(data[2]) || (ret = parse_emph2(ob, rndr, data + 2, size - 2, c)) == 0)\n\t\t\treturn 0;\n\n\t\treturn ret + 2;\n\t}\n\n\tif (size > 4 && data[1] == c && data[2] == c && data[3] != c) {\n\t\tif (c == '~' || _isspace(data[3]) || (ret = parse_emph3(ob, rndr, data + 3, size - 3, c)) == 0)\n\t\t\treturn 0;\n\n\t\treturn ret + 3;\n\t}\n\n\treturn 0;\n}\n\n\n/* char_linebreak • '\\n' preceded by two spaces (assuming linebreak != 0) */\nstatic size_t\nchar_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tif (offset < 2 || data[-1] != ' ' || data[-2] != ' ')\n\t\treturn 0;\n\n\t/* removing the last space from ob and rendering */\n\twhile (ob->size && ob->data[ob->size - 1] == ' ')\n\t\tob->size--;\n\n\treturn rndr->cb.linebreak(ob, rndr->opaque) ? 1 : 0;\n}\n\n\n/* char_codespan • '`' parsing a code span (assuming codespan != 0) */\nstatic size_t\nchar_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\n\t/* counting the number of backticks in the delimiter */\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\n\t/* finding the next delimiter */\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\n\tif (i < nb && end >= size)\n\t\treturn 0; /* no matching delimiter */\n\n\t/* trimming outside whitespaces */\n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\n\t/* real code span */\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\n\treturn end;\n}\n\n\n/* char_escape • '\\\\' backslash escape */\nstatic size_t\nchar_escape(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tstatic const char *escape_chars = \"\\\\`*_{}[]()#+-.!:|&<>^~\";\n\tstruct buf work = { 0, 0, 0, 0 };\n\n\tif (size > 1) {\n\t\tif (strchr(escape_chars, data[1]) == NULL)\n\t\t\treturn 0;\n\n\t\tif (rndr->cb.normal_text) {\n\t\t\twork.data = data + 1;\n\t\t\twork.size = 1;\n\t\t\trndr->cb.normal_text(ob, &work, rndr->opaque);\n\t\t}\n\t\telse bufputc(ob, data[1]);\n\t} else if (size == 1) {\n\t\tbufputc(ob, data[0]);\n\t}\n\n\treturn 2;\n}\n\n/* char_entity • '&' escaped when it doesn't belong to an entity */\n/* valid entities are assumed to be anything matching &#?[A-Za-z0-9]+; */\nstatic size_t\nchar_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end = 1;\n\tstruct buf work = { 0, 0, 0, 0 };\n\n\tif (end < size && data[end] == '#')\n\t\tend++;\n\n\twhile (end < size && isalnum(data[end]))\n\t\tend++;\n\n\tif (end < size && data[end] == ';')\n\t\tend++; /* real entity */\n\telse\n\t\treturn 0; /* lone '&' */\n\n\tif (rndr->cb.entity) {\n\t\twork.data = data;\n\t\twork.size = end;\n\t\trndr->cb.entity(ob, &work, rndr->opaque);\n\t}\n\telse bufput(ob, data, end);\n\n\treturn end;\n}\n\n/* char_langle_tag • '<' when tags or autolinks are allowed */\nstatic size_t\nchar_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n\tsize_t end = tag_length(data, size, &altype);\n\tstruct buf work = { data, end, 0, 0 };\n\tint ret = 0;\n\n\tif (end > 2) {\n\t\tif (rndr->cb.autolink && altype != MKDA_NOT_AUTOLINK) {\n\t\t\tstruct buf *u_link = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\twork.data = data + 1;\n\t\t\twork.size = end - 2;\n\t\t\tunscape_text(u_link, &work);\n\t\t\tret = rndr->cb.autolink(ob, u_link, altype, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t}\n\t\telse if (rndr->cb.raw_html_tag)\n\t\t\tret = rndr->cb.raw_html_tag(ob, &work, rndr->opaque);\n\t}\n\n\tif (!ret) return 0;\n\telse return end;\n}\n\nstatic size_t\nchar_autolink_www(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tstruct buf *link, *link_url, *link_text;\n\tsize_t link_len, rewind;\n\n\tif (!rndr->cb.link || rndr->in_link_body)\n\t\treturn 0;\n\n\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\tif ((link_len = sd_autolink__www(&rewind, link, data, offset, size, 0)) > 0) {\n\t\tlink_url = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tBUFPUTSL(link_url, \"http://\");\n\t\tbufput(link_url, link->data, link->size);\n\n\t\tob->size -= rewind;\n\t\tif (rndr->cb.normal_text) {\n\t\t\tlink_text = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\trndr->cb.normal_text(link_text, link, rndr->opaque);\n\t\t\trndr->cb.link(ob, link_url, NULL, link_text, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t} else {\n\t\t\trndr->cb.link(ob, link_url, NULL, link, rndr->opaque);\n\t\t}\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\treturn link_len;\n}\n\nstatic size_t\nchar_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tstruct buf *link;\n\tsize_t link_len, rewind;\n\n\tif (!rndr->cb.autolink || rndr->in_link_body)\n\t\treturn 0;\n\n\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\tif ((link_len = sd_autolink__email(&rewind, link, data, offset, size, 0)) > 0) {\n\t\tob->size -= rewind;\n\t\trndr->cb.autolink(ob, link, MKDA_EMAIL, rndr->opaque);\n\t}\n\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\treturn link_len;\n}\n\nstatic size_t\nchar_autolink_url(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tstruct buf *link;\n\tsize_t link_len, rewind;\n\n\tif (!rndr->cb.autolink || rndr->in_link_body)\n\t\treturn 0;\n\n\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\tif ((link_len = sd_autolink__url(&rewind, link, data, offset, size, 0)) > 0) {\n\t\tob->size -= rewind;\n\t\trndr->cb.autolink(ob, link, MKDA_NORMAL, rndr->opaque);\n\t}\n\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\treturn link_len;\n}\n\n/* char_link • '[': parsing a link or an image */\nstatic size_t\nchar_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tint is_img = (offset && data[-1] == '!'), level;\n\tsize_t i = 1, txt_e, link_b = 0, link_e = 0, title_b = 0, title_e = 0;\n\tstruct buf *content = 0;\n\tstruct buf *link = 0;\n\tstruct buf *title = 0;\n\tstruct buf *u_link = 0;\n\tsize_t org_work_size = rndr->work_bufs[BUFFER_SPAN].size;\n\tint text_has_nl = 0, ret = 0;\n\tint in_title = 0, qtype = 0;\n\n\t/* checking whether the correct renderer exists */\n\tif ((is_img && !rndr->cb.image) || (!is_img && !rndr->cb.link))\n\t\tgoto cleanup;\n\n\t/* looking for the matching closing bracket */\n\tfor (level = 1; i < size; i++) {\n\t\tif (data[i] == '\\n')\n\t\t\ttext_has_nl = 1;\n\n\t\telse if (data[i - 1] == '\\\\')\n\t\t\tcontinue;\n\n\t\telse if (data[i] == '[')\n\t\t\tlevel++;\n\n\t\telse if (data[i] == ']') {\n\t\t\tlevel--;\n\t\t\tif (level <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= size)\n\t\tgoto cleanup;\n\n\ttxt_e = i;\n\ti++;\n\n\t/* skip any amount of whitespace or newline */\n\t/* (this is much more laxist than original markdown syntax) */\n\twhile (i < size && _isspace(data[i]))\n\t\ti++;\n\n\t/* inline style link */\n\tif (i < size && data[i] == '(') {\n\t\t/* skipping initial whitespace */\n\t\ti++;\n\n\t\twhile (i < size && _isspace(data[i]))\n\t\t\ti++;\n\n\t\tlink_b = i;\n\n\t\t/* looking for link end: ' \" ) */\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == ')') break;\n\t\t\telse if (i >= 1 && _isspace(data[i-1]) && (data[i] == '\\'' || data[i] == '\"')) break;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* looking for title end if present */\n\t\tif (data[i] == '\\'' || data[i] == '\"') {\n\t\t\tqtype = data[i];\n\t\t\tin_title = 1;\n\t\t\ti++;\n\t\t\ttitle_b = i;\n\n\t\t\twhile (i < size) {\n\t\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\t\telse if (data[i] == qtype) {in_title = 0; i++;}\n\t\t\t\telse if ((data[i] == ')') && !in_title) break;\n\t\t\t\telse i++;\n\t\t\t}\n\n\t\t\tif (i >= size) goto cleanup;\n\n\t\t\t/* skipping whitespaces after title */\n\t\t\ttitle_e = i - 1;\n\t\t\twhile (title_e > title_b && _isspace(data[title_e]))\n\t\t\t\ttitle_e--;\n\n\t\t\t/* checking for closing quote presence */\n\t\t\tif (data[title_e] != '\\'' &&  data[title_e] != '\"') {\n\t\t\t\ttitle_b = title_e = 0;\n\t\t\t\tlink_e = i;\n\t\t\t}\n\t\t}\n\n\t\t/* remove whitespace at the end of the link */\n\t\twhile (link_e > link_b && _isspace(data[link_e - 1]))\n\t\t\tlink_e--;\n\n\t\t/* remove optional angle brackets around the link */\n\t\tif (data[link_b] == '<') link_b++;\n\t\tif (data[link_e - 1] == '>') link_e--;\n\n\t\t/* building escaped link and title */\n\t\tif (link_e > link_b) {\n\t\t\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tbufput(link, data + link_b, link_e - link_b);\n\t\t}\n\n\t\tif (title_e > title_b) {\n\t\t\ttitle = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tbufput(title, data + title_b, title_e - title_b);\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/* reference style link */\n\telse if (i < size && data[i] == '[') {\n\t\tstruct buf id = { 0, 0, 0, 0 };\n\t\tstruct link_ref *lr;\n\n\t\t/* looking for the id */\n\t\ti++;\n\t\tlink_b = i;\n\t\twhile (i < size && data[i] != ']') i++;\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* finding the link_ref */\n\t\tif (link_b == link_e) {\n\t\t\tif (text_has_nl) {\n\t\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\t\tsize_t j;\n\n\t\t\t\tfor (j = 1; j < txt_e; j++) {\n\t\t\t\t\tif (data[j] != '\\n')\n\t\t\t\t\t\tbufputc(b, data[j]);\n\t\t\t\t\telse if (data[j - 1] != ' ')\n\t\t\t\t\t\tbufputc(b, ' ');\n\t\t\t\t}\n\n\t\t\t\tid.data = b->data;\n\t\t\t\tid.size = b->size;\n\t\t\t} else {\n\t\t\t\tid.data = data + 1;\n\t\t\t\tid.size = txt_e - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tid.data = data + link_b;\n\t\t\tid.size = link_e - link_b;\n\t\t}\n\n\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n\t\tif (!lr)\n\t\t\tgoto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\t\ti++;\n\t}\n\n\t/* shortcut reference style link */\n\telse {\n\t\tstruct buf id = { 0, 0, 0, 0 };\n\t\tstruct link_ref *lr;\n\n\t\t/* crafting the id */\n\t\tif (text_has_nl) {\n\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tsize_t j;\n\n\t\t\tfor (j = 1; j < txt_e; j++) {\n\t\t\t\tif (data[j] != '\\n')\n\t\t\t\t\tbufputc(b, data[j]);\n\t\t\t\telse if (data[j - 1] != ' ')\n\t\t\t\t\tbufputc(b, ' ');\n\t\t\t}\n\n\t\t\tid.data = b->data;\n\t\t\tid.size = b->size;\n\t\t} else {\n\t\t\tid.data = data + 1;\n\t\t\tid.size = txt_e - 1;\n\t\t}\n\n\t\t/* finding the link_ref */\n\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n\t\tif (!lr)\n\t\t\tgoto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\n\t\t/* rewinding the whitespace */\n\t\ti = txt_e + 1;\n\t}\n\n\t/* building content: img alt is escaped, link content is parsed */\n\tif (txt_e > 1) {\n\t\tcontent = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tif (is_img) {\n\t\t\tbufput(content, data + 1, txt_e - 1);\n\t\t} else {\n\t\t\t/* disable autolinking when parsing inline the\n\t\t\t * content of a link */\n\t\t\trndr->in_link_body = 1;\n\t\t\tparse_inline(content, rndr, data + 1, txt_e - 1);\n\t\t\trndr->in_link_body = 0;\n\t\t}\n\t}\n\n\tif (link) {\n\t\tu_link = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tunscape_text(u_link, link);\n\t}\n\n\t/* calling the relevant rendering function */\n\tif (is_img) {\n\t\tif (ob->size && ob->data[ob->size - 1] == '!')\n\t\t\tob->size -= 1;\n\n\t\tret = rndr->cb.image(ob, u_link, title, content, rndr->opaque);\n\t} else {\n\t\tret = rndr->cb.link(ob, u_link, title, content, rndr->opaque);\n\t}\n\n\t/* cleanup */\ncleanup:\n\trndr->work_bufs[BUFFER_SPAN].size = (int)org_work_size;\n\treturn ret ? i : 0;\n}\n\nstatic size_t\nchar_superscript(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t sup_start, sup_len;\n\tstruct buf *sup;\n\n\tif (!rndr->cb.superscript)\n\t\treturn 0;\n\n\tif (size < 2)\n\t\treturn 0;\n\n\tif (data[1] == '(') {\n\t\tsup_start = sup_len = 2;\n\n\t\twhile (sup_len < size && data[sup_len] != ')' && data[sup_len - 1] != '\\\\')\n\t\t\tsup_len++;\n\n\t\tif (sup_len == size)\n\t\t\treturn 0;\n\t} else {\n\t\tsup_start = sup_len = 1;\n\n\t\twhile (sup_len < size && !_isspace(data[sup_len]))\n\t\t\tsup_len++;\n\t}\n\n\tif (sup_len - sup_start == 0)\n\t\treturn (sup_start == 2) ? 3 : 0;\n\n\tsup = rndr_newbuf(rndr, BUFFER_SPAN);\n\tparse_inline(sup, rndr, data + sup_start, sup_len - sup_start);\n\trndr->cb.superscript(ob, sup, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\n\treturn (sup_start == 2) ? sup_len + 1 : sup_len;\n}\n\n/*********************************\n * BLOCK-LEVEL PARSING FUNCTIONS *\n *********************************/\n\n/* is_empty • returns the line length when it is empty, 0 otherwise */\nstatic size_t\nis_empty(uint8_t *data, size_t size)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\n\treturn i + 1;\n}\n\n/* is_hrule • returns whether a line is a horizontal rule */\nstatic int\nis_hrule(uint8_t *data, size_t size)\n{\n\tsize_t i = 0, n = 0;\n\tuint8_t c;\n\n\t/* skipping initial spaces */\n\tif (size < 3) return 0;\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\t/* looking at the hrule uint8_t */\n\tif (i + 2 >= size\n\t|| (data[i] != '*' && data[i] != '-' && data[i] != '_'))\n\t\treturn 0;\n\tc = data[i];\n\n\t/* the whole line must be the char or whitespace */\n\twhile (i < size && data[i] != '\\n') {\n\t\tif (data[i] == c) n++;\n\t\telse if (data[i] != ' ')\n\t\t\treturn 0;\n\n\t\ti++;\n\t}\n\n\treturn n >= 3;\n}\n\n/* check if a line begins with a code fence; return the\n * width of the code fence */\nstatic size_t\nprefix_codefence(uint8_t *data, size_t size)\n{\n\tsize_t i = 0, n = 0;\n\tuint8_t c;\n\n\t/* skipping initial spaces */\n\tif (size < 3) return 0;\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\t/* looking at the hrule uint8_t */\n\tif (i + 2 >= size || !(data[i] == '~' || data[i] == '`'))\n\t\treturn 0;\n\n\tc = data[i];\n\n\t/* the whole line must be the uint8_t or whitespace */\n\twhile (i < size && data[i] == c) {\n\t\tn++; i++;\n\t}\n\n\tif (n < 3)\n\t\treturn 0;\n\n\treturn i;\n}\n\n/* check if a line is a code fence; return its size if it is */\nstatic size_t\nis_codefence(uint8_t *data, size_t size, struct buf *syntax)\n{\n\tsize_t i = 0, syn_len = 0;\n\tuint8_t *syn_start;\n\n\ti = prefix_codefence(data, size);\n\tif (i == 0)\n\t\treturn 0;\n\n\twhile (i < size && data[i] == ' ')\n\t\ti++;\n\n\tsyn_start = data + i;\n\n\tif (i < size && data[i] == '{') {\n\t\ti++; syn_start++;\n\n\t\twhile (i < size && data[i] != '}' && data[i] != '\\n') {\n\t\t\tsyn_len++; i++;\n\t\t}\n\n\t\tif (i == size || data[i] != '}')\n\t\t\treturn 0;\n\n\t\t/* strip all whitespace at the beginning and the end\n\t\t * of the {} block */\n\t\twhile (syn_len > 0 && _isspace(syn_start[0])) {\n\t\t\tsyn_start++; syn_len--;\n\t\t}\n\n\t\twhile (syn_len > 0 && _isspace(syn_start[syn_len - 1]))\n\t\t\tsyn_len--;\n\n\t\ti++;\n\t} else {\n\t\twhile (i < size && !_isspace(data[i])) {\n\t\t\tsyn_len++; i++;\n\t\t}\n\t}\n\n\tif (syntax) {\n\t\tsyntax->data = syn_start;\n\t\tsyntax->size = syn_len;\n\t}\n\n\twhile (i < size && data[i] != '\\n') {\n\t\tif (!_isspace(data[i]))\n\t\t\treturn 0;\n\n\t\ti++;\n\t}\n\n\treturn i + 1;\n}\n\n/* is_atxheader • returns whether the line is a hash-prefixed header */\nstatic int\nis_atxheader(struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tif (data[0] != '#')\n\t\treturn 0;\n\n\tif (rndr->ext_flags & MKDEXT_SPACE_HEADERS) {\n\t\tsize_t level = 0;\n\n\t\twhile (level < size && level < 6 && data[level] == '#')\n\t\t\tlevel++;\n\n\t\tif (level < size && data[level] != ' ')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* is_headerline • returns whether the line is a setext-style hdr underline */\nstatic int\nis_headerline(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\t/* test of level 1 header */\n\tif (data[i] == '=') {\n\t\tfor (i = 1; i < size && data[i] == '='; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 1 : 0; }\n\n\t/* test of level 2 header */\n\tif (data[i] == '-') {\n\t\tfor (i = 1; i < size && data[i] == '-'; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 2 : 0; }\n\n\treturn 0;\n}\n\nstatic int\nis_next_headerline(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\twhile (i < size && data[i] != '\\n')\n\t\ti++;\n\n\tif (++i >= size)\n\t\treturn 0;\n\n\treturn is_headerline(data + i, size - i);\n}\n\n/* prefix_quote • returns blockquote prefix length */\nstatic size_t\nprefix_quote(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i < size && data[i] == '>') {\n\t\tif (i + 1 < size && data[i + 1] == ' ')\n\t\t\treturn i + 2;\n\n\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\n/* prefix_code • returns prefix length for block code*/\nstatic size_t\nprefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\n\treturn 0;\n}\n\n/* prefix_oli • returns ordered list item prefix */\nstatic size_t\nprefix_oli(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i >= size || data[i] < '0' || data[i] > '9')\n\t\treturn 0;\n\n\twhile (i < size && data[i] >= '0' && data[i] <= '9')\n\t\ti++;\n\n\tif (i + 1 >= size || data[i] != '.' || data[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}\n\n/* prefix_uli • returns ordered list item prefix */\nstatic size_t\nprefix_uli(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i + 1 >= size ||\n\t\t(data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n\t\tdata[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}\n\n\n/* parse_block • parsing of one block, returning next uint8_t to parse */\nstatic void parse_block(struct buf *ob, struct sd_markdown *rndr,\n\t\t\tuint8_t *data, size_t size);\n\n\n/* parse_blockquote • handles parsing of a blockquote fragment */\nstatic size_t\nparse_blockquote(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t beg, end = 0, pre, work_size = 0;\n\tuint8_t *work_data = 0;\n\tstruct buf *out = 0;\n\n\tout = rndr_newbuf(rndr, BUFFER_BLOCK);\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tpre = prefix_quote(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\n\t\t/* empty line followed by non-quote line */\n\t\telse if (is_empty(data + beg, end - beg) &&\n\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n\t\t\t\t!is_empty(data + end, size - end))))\n\t\t\tbreak;\n\n\t\tif (beg < end) { /* copy into the in-place working buffer */\n\t\t\t/* bufput(work, data + beg, end - beg); */\n\t\t\tif (!work_data)\n\t\t\t\twork_data = data + beg;\n\t\t\telse if (data + beg != work_data + work_size)\n\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n\t\t\twork_size += end - beg;\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tparse_block(out, rndr, work_data, work_size);\n\tif (rndr->cb.blockquote)\n\t\trndr->cb.blockquote(ob, out, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn end;\n}\n\nstatic size_t\nparse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render);\n\n/* parse_blockquote • handles parsing of a regular paragraph */\nstatic size_t\nparse_paragraph(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t i = 0, end = 0;\n\tint level = 0;\n\tstruct buf work = { data, 0, 0, 0 };\n\n\twhile (i < size) {\n\t\tfor (end = i + 1; end < size && data[end - 1] != '\\n'; end++) /* empty */;\n\n\t\tif (is_empty(data + i, size - i))\n\t\t\tbreak;\n\n\t\tif ((level = is_headerline(data + i, size - i)) != 0)\n\t\t\tbreak;\n\n\t\tif (is_atxheader(rndr, data + i, size - i) ||\n\t\t\tis_hrule(data + i, size - i) ||\n\t\t\tprefix_quote(data + i, size - i)) {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Early termination of a paragraph with the same logic\n\t\t * as Markdown 1.0.0. If this logic is applied, the\n\t\t * Markdown 1.0.3 test suite won't pass cleanly\n\t\t *\n\t\t * :: If the first character in a new line is not a letter,\n\t\t * let's check to see if there's some kind of block starting\n\t\t * here\n\t\t */\n\t\tif ((rndr->ext_flags & MKDEXT_LAX_SPACING) && !isalnum(data[i])) {\n\t\t\tif (prefix_oli(data + i, size - i) ||\n\t\t\t\tprefix_uli(data + i, size - i)) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* see if an html block starts here */\n\t\t\tif (data[i] == '<' && rndr->cb.blockhtml &&\n\t\t\t\tparse_htmlblock(ob, rndr, data + i, size - i, 0)) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* see if a code fence starts here */\n\t\t\tif ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n\t\t\t\tis_codefence(data + i, size - i, NULL) != 0) {\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ti = end;\n\t}\n\n\twork.size = i;\n\twhile (work.size && data[work.size - 1] == '\\n')\n\t\twork.size--;\n\n\tif (!level) {\n\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n\t\tparse_inline(tmp, rndr, work.data, work.size);\n\t\tif (rndr->cb.paragraph)\n\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n\t} else {\n\t\tstruct buf *header_work;\n\n\t\tif (work.size) {\n\t\t\tsize_t beg;\n\t\t\ti = work.size;\n\t\t\twork.size -= 1;\n\n\t\t\twhile (work.size && data[work.size] != '\\n')\n\t\t\t\twork.size -= 1;\n\n\t\t\tbeg = work.size + 1;\n\t\t\twhile (work.size && data[work.size - 1] == '\\n')\n\t\t\t\twork.size -= 1;\n\n\t\t\tif (work.size > 0) {\n\t\t\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n\t\t\t\tparse_inline(tmp, rndr, work.data, work.size);\n\n\t\t\t\tif (rndr->cb.paragraph)\n\t\t\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n\n\t\t\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n\t\t\t\twork.data += beg;\n\t\t\t\twork.size = i - beg;\n\t\t\t}\n\t\t\telse work.size = i;\n\t\t}\n\n\t\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(header_work, rndr, work.data, work.size);\n\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, header_work, (int)level, rndr->opaque);\n\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\n\treturn end;\n}\n\n/* parse_fencedcode • handles parsing of a block-level code fragment */\nstatic size_t\nparse_fencedcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t beg, end;\n\tstruct buf *work = 0;\n\tstruct buf lang = { 0, 0, 0, 0 };\n\n\tbeg = is_codefence(data, size, &lang);\n\tif (beg == 0) return 0;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\twhile (beg < size) {\n\t\tsize_t fence_end;\n\t\tstruct buf fence_trail = { 0, 0, 0, 0 };\n\n\t\tfence_end = is_codefence(data + beg, size - beg, &fence_trail);\n\t\tif (fence_end != 0 && fence_trail.size == 0) {\n\t\t\tbeg += fence_end;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tif (beg < end) {\n\t\t\t/* verbatim copy to the working buffer,\n\t\t\t\tescaping entities */\n\t\t\tif (is_empty(data + beg, end - beg))\n\t\t\t\tbufputc(work, '\\n');\n\t\t\telse bufput(work, data + beg, end - beg);\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tif (work->size && work->data[work->size - 1] != '\\n')\n\t\tbufputc(work, '\\n');\n\n\tif (rndr->cb.blockcode)\n\t\trndr->cb.blockcode(ob, work, lang.size ? &lang : NULL, rndr->opaque);\n\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn beg;\n}\n\nstatic size_t\nparse_blockcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t beg, end, pre;\n\tstruct buf *work = 0;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++) {};\n\t\tpre = prefix_code(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\t\telse if (!is_empty(data + beg, end - beg))\n\t\t\t/* non-empty non-prefixed line breaks the pre */\n\t\t\tbreak;\n\n\t\tif (beg < end) {\n\t\t\t/* verbatim copy to the working buffer,\n\t\t\t\tescaping entities */\n\t\t\tif (is_empty(data + beg, end - beg))\n\t\t\t\tbufputc(work, '\\n');\n\t\t\telse bufput(work, data + beg, end - beg);\n\t\t}\n\t\tbeg = end;\n\t}\n\n\twhile (work->size && work->data[work->size - 1] == '\\n')\n\t\twork->size -= 1;\n\n\tbufputc(work, '\\n');\n\n\tif (rndr->cb.blockcode)\n\t\trndr->cb.blockcode(ob, work, NULL, rndr->opaque);\n\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn beg;\n}\n\n/* parse_listitem • parsing of a single list item */\n/*\tassuming initial prefix is already removed */\nstatic size_t\nparse_listitem(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int *flags)\n{\n\tstruct buf *work = 0, *inter = 0;\n\tsize_t beg = 0, end, pre, sublist = 0, orgpre = 0, i;\n\tint in_empty = 0, has_inside_empty = 0, in_fence = 0;\n\n\t/* keeping track of the first indentation prefix */\n\twhile (orgpre < 3 && orgpre < size && data[orgpre] == ' ')\n\t\torgpre++;\n\n\tbeg = prefix_uli(data, size);\n\tif (!beg)\n\t\tbeg = prefix_oli(data, size);\n\n\tif (!beg)\n\t\treturn 0;\n\n\t/* skipping to the beginning of the following line */\n\tend = beg;\n\twhile (end < size && data[end - 1] != '\\n')\n\t\tend++;\n\n\t/* getting working buffers */\n\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\tinter = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t/* putting the first line into the working buffer */\n\tbufput(work, data + beg, end - beg);\n\tbeg = end;\n\n\t/* process the following lines */\n\twhile (beg < size) {\n\t\tsize_t has_next_uli = 0, has_next_oli = 0;\n\n\t\tend++;\n\n\t\twhile (end < size && data[end - 1] != '\\n')\n\t\t\tend++;\n\n\t\t/* process an empty line */\n\t\tif (is_empty(data + beg, end - beg)) {\n\t\t\tin_empty = 1;\n\t\t\tbeg = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* calculating the indentation */\n\t\ti = 0;\n\t\twhile (i < 4 && beg + i < end && data[beg + i] == ' ')\n\t\t\ti++;\n\n\t\tpre = i;\n\n\t\tif (rndr->ext_flags & MKDEXT_FENCED_CODE) {\n\t\t\tif (is_codefence(data + beg + i, end - beg - i, NULL) != 0)\n\t\t\t\tin_fence = !in_fence;\n\t\t}\n\n\t\t/* Only check for new list items if we are **not** inside\n\t\t * a fenced code block */\n\t\tif (!in_fence) {\n\t\t\thas_next_uli = prefix_uli(data + beg + i, end - beg - i);\n\t\t\thas_next_oli = prefix_oli(data + beg + i, end - beg - i);\n\t\t}\n\n\t\t/* checking for ul/ol switch */\n\t\tif (in_empty && (\n\t\t\t((*flags & MKD_LIST_ORDERED) && has_next_uli) ||\n\t\t\t(!(*flags & MKD_LIST_ORDERED) && has_next_oli))){\n\t\t\t*flags |= MKD_LI_END;\n\t\t\tbreak; /* the following item must have same list type */\n\t\t}\n\n\t\t/* checking for a new item */\n\t\tif ((has_next_uli && !is_hrule(data + beg + i, end - beg - i)) || has_next_oli) {\n\t\t\tif (in_empty)\n\t\t\t\thas_inside_empty = 1;\n\n\t\t\tif (pre == orgpre) /* the following item must have */\n\t\t\t\tbreak;             /* the same indentation */\n\n\t\t\tif (!sublist)\n\t\t\t\tsublist = work->size;\n\t\t}\n\t\t/* joining only indented stuff after empty lines;\n\t\t * note that now we only require 1 space of indentation\n\t\t * to continue a list */\n\t\telse if (in_empty && pre == 0) {\n\t\t\t*flags |= MKD_LI_END;\n\t\t\tbreak;\n\t\t}\n\t\telse if (in_empty) {\n\t\t\tbufputc(work, '\\n');\n\t\t\thas_inside_empty = 1;\n\t\t}\n\n\t\tin_empty = 0;\n\n\t\t/* adding the line without prefix into the working buffer */\n\t\tbufput(work, data + beg + i, end - beg - i);\n\t\tbeg = end;\n\t}\n\n\t/* render of li contents */\n\tif (has_inside_empty)\n\t\t*flags |= MKD_LI_BLOCK;\n\n\tif (*flags & MKD_LI_BLOCK) {\n\t\t/* intermediate render of block li */\n\t\tif (sublist && sublist < work->size) {\n\t\t\tparse_block(inter, rndr, work->data, sublist);\n\t\t\tparse_block(inter, rndr, work->data + sublist, work->size - sublist);\n\t\t}\n\t\telse\n\t\t\tparse_block(inter, rndr, work->data, work->size);\n\t} else {\n\t\t/* intermediate render of inline li */\n\t\tif (sublist && sublist < work->size) {\n\t\t\tparse_inline(inter, rndr, work->data, sublist);\n\t\t\tparse_block(inter, rndr, work->data + sublist, work->size - sublist);\n\t\t}\n\t\telse\n\t\t\tparse_inline(inter, rndr, work->data, work->size);\n\t}\n\n\t/* render of li itself */\n\tif (rndr->cb.listitem)\n\t\trndr->cb.listitem(ob, inter, *flags, rndr->opaque);\n\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\treturn beg;\n}\n\n\n/* parse_list • parsing ordered or unordered list block */\nstatic size_t\nparse_list(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int flags)\n{\n\tstruct buf *work = 0;\n\tsize_t i = 0, j;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\twhile (i < size) {\n\t\tj = parse_listitem(work, rndr, data + i, size - i, &flags);\n\t\ti += j;\n\n\t\tif (!j || (flags & MKD_LI_END))\n\t\t\tbreak;\n\t}\n\n\tif (rndr->cb.list)\n\t\trndr->cb.list(ob, work, flags, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}\n\n/* parse_atxheader • parsing of atx-style headers */\nstatic size_t\nparse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\tparse_inline(work, rndr, data + i, end - i);\n\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\n\treturn skip;\n}\n\n\n/* htmlblock_end • checking end of HTML block : </tag>[ \\t]*\\n[ \\t*]\\n */\n/*\treturns the length on match, 0 otherwise */\nstatic size_t\nhtmlblock_end_tag(\n\tconst char *tag,\n\tsize_t tag_len,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i, w;\n\n\t/* checking if tag is a match */\n\tif (tag_len + 3 >= size ||\n\t\tstrncasecmp((char *)data + 2, tag, tag_len) != 0 ||\n\t\tdata[tag_len + 2] != '>')\n\t\treturn 0;\n\n\t/* checking white lines */\n\ti = tag_len + 3;\n\tw = 0;\n\tif (i < size && (w = is_empty(data + i, size - i)) == 0)\n\t\treturn 0; /* non-blank after tag */\n\ti += w;\n\tw = 0;\n\n\tif (i < size)\n\t\tw = is_empty(data + i, size - i);\n\n\treturn i + w;\n}\n\nstatic size_t\nhtmlblock_end(const char *curtag,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size,\n\tint start_of_line)\n{\n\tsize_t tag_size = strlen(curtag);\n\tsize_t i = 1, end_tag;\n\tint block_lines = 0;\n\n\twhile (i < size) {\n\t\ti++;\n\t\twhile (i < size && !(data[i - 1] == '<' && data[i] == '/')) {\n\t\t\tif (data[i] == '\\n')\n\t\t\t\tblock_lines++;\n\n\t\t\ti++;\n\t\t}\n\n\t\t/* If we are only looking for unindented tags, skip the tag\n\t\t * if it doesn't follow a newline.\n\t\t *\n\t\t * The only exception to this is if the tag is still on the\n\t\t * initial line; in that case it still counts as a closing\n\t\t * tag\n\t\t */\n\t\tif (start_of_line && block_lines > 0 && data[i - 2] != '\\n')\n\t\t\tcontinue;\n\n\t\tif (i + 2 + tag_size >= size)\n\t\t\tbreak;\n\n\t\tend_tag = htmlblock_end_tag(curtag, tag_size, rndr, data + i - 1, size - i + 1);\n\t\tif (end_tag)\n\t\t\treturn i + end_tag - 1;\n\t}\n\n\treturn 0;\n}\n\n\n/* parse_htmlblock • parsing of inline HTML block */\nstatic size_t\nparse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render)\n{\n\tsize_t i, j = 0, tag_end;\n\tconst char *curtag = NULL;\n\tstruct buf work = { data, 0, 0, 0 };\n\n\t/* identification of the opening tag */\n\tif (size < 2 || data[0] != '<')\n\t\treturn 0;\n\n\ti = 1;\n\twhile (i < size && data[i] != '>' && data[i] != ' ')\n\t\ti++;\n\n\tif (i < size)\n\t\tcurtag = find_block_tag((char *)data + 1, (int)i - 1);\n\n\t/* handling of special cases */\n\tif (!curtag) {\n\n\t\t/* HTML comment, laxist form */\n\t\tif (size > 5 && data[1] == '!' && data[2] == '-' && data[3] == '-') {\n\t\t\ti = 5;\n\n\t\t\twhile (i < size && !(data[i - 2] == '-' && data[i - 1] == '-' && data[i] == '>'))\n\t\t\t\ti++;\n\n\t\t\ti++;\n\n\t\t\tif (i < size)\n\t\t\t\tj = is_empty(data + i, size - i);\n\n\t\t\tif (j) {\n\t\t\t\twork.size = i + j;\n\t\t\t\tif (do_render && rndr->cb.blockhtml)\n\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n\t\t\t\treturn work.size;\n\t\t\t}\n\t\t}\n\n\t\t/* HR, which is the only self-closing block tag considered */\n\t\tif (size > 4 && (data[1] == 'h' || data[1] == 'H') && (data[2] == 'r' || data[2] == 'R')) {\n\t\t\ti = 3;\n\t\t\twhile (i < size && data[i] != '>')\n\t\t\t\ti++;\n\n\t\t\tif (i + 1 < size) {\n\t\t\t\ti++;\n\t\t\t\tj = is_empty(data + i, size - i);\n\t\t\t\tif (j) {\n\t\t\t\t\twork.size = i + j;\n\t\t\t\t\tif (do_render && rndr->cb.blockhtml)\n\t\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n\t\t\t\t\treturn work.size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* no special case recognised */\n\t\treturn 0;\n\t}\n\n\t/* looking for an unindented matching closing tag */\n\t/*\tfollowed by a blank line */\n\ttag_end = htmlblock_end(curtag, rndr, data, size, 1);\n\n\t/* if not found, trying a second pass looking for indented match */\n\t/* but not if tag is \"ins\" or \"del\" (following original Markdown.pl) */\n\tif (!tag_end && strcmp(curtag, \"ins\") != 0 && strcmp(curtag, \"del\") != 0) {\n\t\ttag_end = htmlblock_end(curtag, rndr, data, size, 0);\n\t}\n\n\tif (!tag_end)\n\t\treturn 0;\n\n\t/* the end of the block has been found */\n\twork.size = tag_end;\n\tif (do_render && rndr->cb.blockhtml)\n\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n\n\treturn tag_end;\n}\n\nstatic void\nparse_table_row(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size,\n\tsize_t columns,\n\tint *col_data,\n\tint header_flag)\n{\n\tsize_t i = 0, col;\n\tstruct buf *row_work = 0;\n\n\tif (!rndr->cb.table_cell || !rndr->cb.table_row)\n\t\treturn;\n\n\trow_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\tif (i < size && data[i] == '|')\n\t\ti++;\n\n\tfor (col = 0; col < columns && i < size; ++col) {\n\t\tsize_t cell_start, cell_end;\n\t\tstruct buf *cell_work;\n\n\t\tcell_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\n\t\twhile (i < size && _isspace(data[i]))\n\t\t\ti++;\n\n\t\tcell_start = i;\n\n\t\twhile (i < size && data[i] != '|')\n\t\t\ti++;\n\n\t\tcell_end = i - 1;\n\n\t\twhile (cell_end > cell_start && _isspace(data[cell_end]))\n\t\t\tcell_end--;\n\n\t\tparse_inline(cell_work, rndr, data + cell_start, 1 + cell_end - cell_start);\n\t\trndr->cb.table_cell(row_work, cell_work, col_data[col] | header_flag, rndr->opaque);\n\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\ti++;\n\t}\n\n\tfor (; col < columns; ++col) {\n\t\tstruct buf empty_cell = { 0, 0, 0, 0 };\n\t\trndr->cb.table_cell(row_work, &empty_cell, col_data[col] | header_flag, rndr->opaque);\n\t}\n\n\trndr->cb.table_row(ob, row_work, rndr->opaque);\n\n\trndr_popbuf(rndr, BUFFER_SPAN);\n}\n\nstatic size_t\nparse_table_header(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size,\n\tsize_t *columns,\n\tint **column_data)\n{\n\tint pipes;\n\tsize_t i = 0, col, header_end, under_end;\n\n\tpipes = 0;\n\twhile (i < size && data[i] != '\\n')\n\t\tif (data[i++] == '|')\n\t\t\tpipes++;\n\n\tif (i == size || pipes == 0)\n\t\treturn 0;\n\n\theader_end = i;\n\n\twhile (header_end > 0 && _isspace(data[header_end - 1]))\n\t\theader_end--;\n\n\tif (data[0] == '|')\n\t\tpipes--;\n\n\tif (header_end && data[header_end - 1] == '|')\n\t\tpipes--;\n\n\t*columns = pipes + 1;\n\t*column_data = calloc(*columns, sizeof(int));\n\n\t/* Parse the header underline */\n\ti++;\n\tif (i < size && data[i] == '|')\n\t\ti++;\n\n\tunder_end = i;\n\twhile (under_end < size && data[under_end] != '\\n')\n\t\tunder_end++;\n\n\tfor (col = 0; col < *columns && i < under_end; ++col) {\n\t\tsize_t dashes = 0;\n\n\t\twhile (i < under_end && data[i] == ' ')\n\t\t\ti++;\n\n\t\tif (data[i] == ':') {\n\t\t\ti++; (*column_data)[col] |= MKD_TABLE_ALIGN_L;\n\t\t\tdashes++;\n\t\t}\n\n\t\twhile (i < under_end && data[i] == '-') {\n\t\t\ti++; dashes++;\n\t\t}\n\n\t\tif (i < under_end && data[i] == ':') {\n\t\t\ti++; (*column_data)[col] |= MKD_TABLE_ALIGN_R;\n\t\t\tdashes++;\n\t\t}\n\n\t\twhile (i < under_end && data[i] == ' ')\n\t\t\ti++;\n\n\t\tif (i < under_end && data[i] != '|')\n\t\t\tbreak;\n\n\t\tif (dashes < 3)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tif (col < *columns)\n\t\treturn 0;\n\n\tparse_table_row(\n\t\tob, rndr, data,\n\t\theader_end,\n\t\t*columns,\n\t\t*column_data,\n\t\tMKD_TABLE_HEADER\n\t);\n\n\treturn under_end + 1;\n}\n\nstatic size_t\nparse_table(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i;\n\n\tstruct buf *header_work = 0;\n\tstruct buf *body_work = 0;\n\n\tsize_t columns;\n\tint *col_data = NULL;\n\n\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n\tif (i > 0) {\n\n\t\twhile (i < size) {\n\t\t\tsize_t row_start;\n\t\t\tint pipes = 0;\n\n\t\t\trow_start = i;\n\n\t\t\twhile (i < size && data[i] != '\\n')\n\t\t\t\tif (data[i++] == '|')\n\t\t\t\t\tpipes++;\n\n\t\t\tif (pipes == 0 || i == size) {\n\t\t\t\ti = row_start;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparse_table_row(\n\t\t\t\tbody_work,\n\t\t\t\trndr,\n\t\t\t\tdata + row_start,\n\t\t\t\ti - row_start,\n\t\t\t\tcolumns,\n\t\t\t\tcol_data, 0\n\t\t\t);\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (rndr->cb.table)\n\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n\t}\n\n\tfree(col_data);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}\n\n/* parse_block • parsing of one block, returning next uint8_t to parse */\nstatic void\nparse_block(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t beg, end, i;\n\tuint8_t *txt_data;\n\tbeg = 0;\n\n\tif (rndr->work_bufs[BUFFER_SPAN].size +\n\t\trndr->work_bufs[BUFFER_BLOCK].size > rndr->max_nesting)\n\t\treturn;\n\n\twhile (beg < size) {\n\t\ttxt_data = data + beg;\n\t\tend = size - beg;\n\n\t\tif (is_atxheader(rndr, txt_data, end))\n\t\t\tbeg += parse_atxheader(ob, rndr, txt_data, end);\n\n\t\telse if (data[beg] == '<' && rndr->cb.blockhtml &&\n\t\t\t\t(i = parse_htmlblock(ob, rndr, txt_data, end, 1)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if ((i = is_empty(txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if (is_hrule(txt_data, end)) {\n\t\t\tif (rndr->cb.hrule)\n\t\t\t\trndr->cb.hrule(ob, rndr->opaque);\n\n\t\t\twhile (beg < size && data[beg] != '\\n')\n\t\t\t\tbeg++;\n\n\t\t\tbeg++;\n\t\t}\n\n\t\telse if ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n\t\t\t(i = parse_fencedcode(ob, rndr, txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if ((rndr->ext_flags & MKDEXT_TABLES) != 0 &&\n\t\t\t(i = parse_table(ob, rndr, txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if (prefix_quote(txt_data, end))\n\t\t\tbeg += parse_blockquote(ob, rndr, txt_data, end);\n\n\t\telse if (prefix_code(txt_data, end))\n\t\t\tbeg += parse_blockcode(ob, rndr, txt_data, end);\n\n\t\telse if (prefix_uli(txt_data, end))\n\t\t\tbeg += parse_list(ob, rndr, txt_data, end, 0);\n\n\t\telse if (prefix_oli(txt_data, end))\n\t\t\tbeg += parse_list(ob, rndr, txt_data, end, MKD_LIST_ORDERED);\n\n\t\telse\n\t\t\tbeg += parse_paragraph(ob, rndr, txt_data, end);\n\t}\n}\n\n\n\n/*********************\n * REFERENCE PARSING *\n *********************/\n\n/* is_ref • returns whether a line is a reference or not */\nstatic int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && data[i] == ' ') i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->link = bufnew(link_end - link_offset);\n\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = bufnew(title_end - title_offset);\n\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void expand_tabs(struct buf *ob, const uint8_t *line, size_t size)\n{\n\tsize_t  i = 0, tab = 0;\n\n\twhile (i < size) {\n\t\tsize_t org = i;\n\n\t\twhile (i < size && line[i] != '\\t') {\n\t\t\ti++; tab++;\n\t\t}\n\n\t\tif (i > org)\n\t\t\tbufput(ob, line + org, i - org);\n\n\t\tif (i >= size)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tbufputc(ob, ' '); tab++;\n\t\t} while (tab % 4);\n\n\t\ti++;\n\t}\n}\n\n/**********************\n * EXPORTED FUNCTIONS *\n **********************/\n\nstruct sd_markdown *\nsd_markdown_new(\n\tunsigned int extensions,\n\tsize_t max_nesting,\n\tconst struct sd_callbacks *callbacks,\n\tvoid *opaque)\n{\n\tstruct sd_markdown *md = NULL;\n\n\tassert(max_nesting > 0 && callbacks);\n\n\tmd = malloc(sizeof(struct sd_markdown));\n\tif (!md)\n\t\treturn NULL;\n\n\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n\n\tstack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n\tstack_init(&md->work_bufs[BUFFER_SPAN], 8);\n\n\tmemset(md->active_char, 0x0, 256);\n\n\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n\t}\n\n\tif (md->cb.codespan)\n\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n\n\tif (md->cb.linebreak)\n\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\n\tif (md->cb.image || md->cb.link)\n\t\tmd->active_char['['] = MD_CHAR_LINK;\n\n\tmd->active_char['<'] = MD_CHAR_LANGLE;\n\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n\n\tif (extensions & MKDEXT_AUTOLINK) {\n\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t}\n\n\tif (extensions & MKDEXT_SUPERSCRIPT)\n\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\n\t/* Extension data */\n\tmd->ext_flags = extensions;\n\tmd->opaque = opaque;\n\tmd->max_nesting = max_nesting;\n\tmd->in_link_body = 0;\n\n\treturn md;\n}\n\nvoid\nsd_markdown_render(struct buf *ob, const uint8_t *document, size_t doc_size, struct sd_markdown *md)\n{\n#define MARKDOWN_GROW(x) ((x) + ((x) >> 1))\n\tstatic const char UTF8_BOM[] = {0xEF, 0xBB, 0xBF};\n\n\tstruct buf *text;\n\tsize_t beg, end;\n\n\ttext = bufnew(64);\n\tif (!text)\n\t\treturn;\n\n\t/* Preallocate enough space for our buffer to avoid expanding while copying */\n\tbufgrow(text, doc_size);\n\n\t/* reset the references table */\n\tmemset(&md->refs, 0x0, REF_TABLE_SIZE * sizeof(void *));\n\n\t/* first pass: looking for references, copying everything else */\n\tbeg = 0;\n\n\t/* Skip a possible UTF-8 BOM, even though the Unicode standard\n\t * discourages having these in UTF-8 documents */\n\tif (doc_size >= 3 && memcmp(document, UTF8_BOM, 3) == 0)\n\t\tbeg += 3;\n\n\twhile (beg < doc_size) /* iterating over lines */\n\t\tif (is_ref(document, beg, doc_size, &end, md->refs))\n\t\t\tbeg = end;\n\t\telse { /* skipping to the next line */\n\t\t\tend = beg;\n\t\t\twhile (end < doc_size && document[end] != '\\n' && document[end] != '\\r')\n\t\t\t\tend++;\n\n\t\t\t/* adding the line body if present */\n\t\t\tif (end > beg)\n\t\t\t\texpand_tabs(text, document + beg, end - beg);\n\n\t\t\twhile (end < doc_size && (document[end] == '\\n' || document[end] == '\\r')) {\n\t\t\t\t/* add one \\n per newline */\n\t\t\t\tif (document[end] == '\\n' || (end + 1 < doc_size && document[end + 1] != '\\n'))\n\t\t\t\t\tbufputc(text, '\\n');\n\t\t\t\tend++;\n\t\t\t}\n\n\t\t\tbeg = end;\n\t\t}\n\n\t/* pre-grow the output buffer to minimize allocations */\n\tbufgrow(ob, MARKDOWN_GROW(text->size));\n\n\t/* second pass: actual rendering */\n\tif (md->cb.doc_header)\n\t\tmd->cb.doc_header(ob, md->opaque);\n\n\tif (text->size) {\n\t\t/* adding a final newline if not already present */\n\t\tif (text->data[text->size - 1] != '\\n' &&  text->data[text->size - 1] != '\\r')\n\t\t\tbufputc(text, '\\n');\n\n\t\tparse_block(ob, md, text->data, text->size);\n\t}\n\n\tif (md->cb.doc_footer)\n\t\tmd->cb.doc_footer(ob, md->opaque);\n\n\t/* clean-up */\n\tbufrelease(text);\n\tfree_link_refs(md->refs);\n\n\tassert(md->work_bufs[BUFFER_SPAN].size == 0);\n\tassert(md->work_bufs[BUFFER_BLOCK].size == 0);\n}\n\nvoid\nsd_markdown_free(struct sd_markdown *md)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < (size_t)md->work_bufs[BUFFER_SPAN].asize; ++i)\n\t\tbufrelease(md->work_bufs[BUFFER_SPAN].item[i]);\n\n\tfor (i = 0; i < (size_t)md->work_bufs[BUFFER_BLOCK].asize; ++i)\n\t\tbufrelease(md->work_bufs[BUFFER_BLOCK].item[i]);\n\n\tstack_free(&md->work_bufs[BUFFER_SPAN]);\n\tstack_free(&md->work_bufs[BUFFER_BLOCK]);\n\n\tfree(md);\n}\n\nvoid\nsd_version(int *ver_major, int *ver_minor, int *ver_revision)\n{\n\t*ver_major = SUNDOWN_VER_MAJOR;\n\t*ver_minor = SUNDOWN_VER_MINOR;\n\t*ver_revision = SUNDOWN_VER_REVISION;\n}\n\n/* vim: set filetype=c: */\n","/* C code produced by gperf version 3.0.3 */\n/* Command-line: gperf -N find_block_tag -H hash_block_tag -C -c -E --ignore-case html_block_names.txt  */\n/* Computed positions: -k'1-2' */\n\n#if !((' ' == 32) && ('!' == 33) && ('\"' == 34) && ('#' == 35) \\\n      && ('%' == 37) && ('&' == 38) && ('\\'' == 39) && ('(' == 40) \\\n      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \\\n      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \\\n      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \\\n      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \\\n      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \\\n      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \\\n      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \\\n      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \\\n      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \\\n      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \\\n      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \\\n      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \\\n      && ('Z' == 90) && ('[' == 91) && ('\\\\' == 92) && (']' == 93) \\\n      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \\\n      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \\\n      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \\\n      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \\\n      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \\\n      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \\\n      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \\\n      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))\n/* The character set is not based on ISO-646.  */\nerror \"gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>.\"\n#endif\n\n/* maximum key range = 37, duplicates = 0 */\n\n#ifndef GPERF_DOWNCASE\n#define GPERF_DOWNCASE 1\nstatic unsigned char gperf_downcase[256] =\n  {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,\n     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,\n     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,\n     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,\n     60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,\n    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,\n    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,\n    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\n    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,\n    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\n    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,\n    255\n  };\n#endif\n\n#ifndef GPERF_CASE_STRNCMP\n#define GPERF_CASE_STRNCMP 1\nstatic int\ngperf_case_strncmp (s1, s2, n)\n     register const char *s1;\n     register const char *s2;\n     register unsigned int n;\n{\n  for (; n > 0;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        {\n          n--;\n          continue;\n        }\n      return (int)c1 - (int)c2;\n    }\n  return 0;\n}\n#endif\n\n#ifdef __GNUC__\n__inline\n#else\n#ifdef __cplusplus\ninline\n#endif\n#endif\nstatic unsigned int\nhash_block_tag (str, len)\n     register const char *str;\n     register unsigned int len;\n{\n  static const unsigned char asso_values[] =\n    {\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n       8, 30, 25, 20, 15, 10, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38,  0, 38,  0, 38,\n       5,  5,  5, 15,  0, 38, 38,  0, 15, 10,\n       0, 38, 38, 15,  0,  5, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38,  0, 38,\n       0, 38,  5,  5,  5, 15,  0, 38, 38,  0,\n      15, 10,  0, 38, 38, 15,  0,  5, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n      38, 38, 38, 38, 38, 38, 38\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[1]+1];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval;\n}\n\n#ifdef __GNUC__\n__inline\n#ifdef __GNUC_STDC_INLINE__\n__attribute__ ((__gnu_inline__))\n#endif\n#endif\nconst char *\nfind_block_tag (str, len)\n     register const char *str;\n     register unsigned int len;\n{\n  enum\n    {\n      TOTAL_KEYWORDS = 24,\n      MIN_WORD_LENGTH = 1,\n      MAX_WORD_LENGTH = 10,\n      MIN_HASH_VALUE = 1,\n      MAX_HASH_VALUE = 37\n    };\n\n  static const char * const wordlist[] =\n    {\n      \"\",\n      \"p\",\n      \"dl\",\n      \"div\",\n      \"math\",\n      \"table\",\n      \"\",\n      \"ul\",\n      \"del\",\n      \"form\",\n      \"blockquote\",\n      \"figure\",\n      \"ol\",\n      \"fieldset\",\n      \"\",\n      \"h1\",\n      \"\",\n      \"h6\",\n      \"pre\",\n      \"\", \"\",\n      \"script\",\n      \"h5\",\n      \"noscript\",\n      \"\",\n      \"style\",\n      \"iframe\",\n      \"h4\",\n      \"ins\",\n      \"\", \"\", \"\",\n      \"h3\",\n      \"\", \"\", \"\", \"\",\n      \"h2\"\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = hash_block_tag (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register const char *s = wordlist[key];\n\n          if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strncmp (str, s, len) && s[len] == '\\0')\n            return s;\n        }\n    }\n  return 0;\n}\n","#include \"stack.h\"\n#include <string.h>\n\nint\nstack_grow(struct stack *st, size_t new_size)\n{\n\tvoid **new_st;\n\n\tif (st->asize >= new_size)\n\t\treturn 0;\n\n\tnew_st = realloc(st->item, new_size * sizeof(void *));\n\tif (new_st == NULL)\n\t\treturn -1;\n\n\tmemset(new_st + st->asize, 0x0,\n\t\t(new_size - st->asize) * sizeof(void *));\n\n\tst->item = new_st;\n\tst->asize = new_size;\n\n\tif (st->size > new_size)\n\t\tst->size = new_size;\n\n\treturn 0;\n}\n\nvoid\nstack_free(struct stack *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tfree(st->item);\n\n\tst->item = NULL;\n\tst->size = 0;\n\tst->asize = 0;\n}\n\nint\nstack_init(struct stack *st, size_t initial_size)\n{\n\tst->item = NULL;\n\tst->size = 0;\n\tst->asize = 0;\n\n\tif (!initial_size)\n\t\tinitial_size = 8;\n\n\treturn stack_grow(st, initial_size);\n}\n\nvoid *\nstack_pop(struct stack *st)\n{\n\tif (!st->size)\n\t\treturn NULL;\n\n\treturn st->item[--st->size];\n}\n\nint\nstack_push(struct stack *st, void *item)\n{\n\tif (stack_grow(st, st->size * 2) < 0)\n\t\treturn -1;\n\n\tst->item[st->size++] = item;\n\treturn 0;\n}\n\nvoid *\nstack_top(struct stack *st)\n{\n\tif (!st->size)\n\t\treturn NULL;\n\n\treturn st->item[st->size - 1];\n}\n\n","/*\n * Copyright (c) 2008, Natacha Porté\n * Copyright (c) 2011, Vicent Martí\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#define BUFFER_MAX_ALLOC_SIZE (1024 * 1024 * 16) //16mb\n\n#include \"buffer.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n/* MSVC compat */\n#if defined(_MSC_VER)\n#\tdefine _buf_vsnprintf _vsnprintf\n#else\n#\tdefine _buf_vsnprintf vsnprintf\n#endif\n\nint\nbufprefix(const struct buf *buf, const char *prefix)\n{\n\tsize_t i;\n\tassert(buf && buf->unit);\n\n\tfor (i = 0; i < buf->size; ++i) {\n\t\tif (prefix[i] == 0)\n\t\t\treturn 0;\n\n\t\tif (buf->data[i] != prefix[i])\n\t\t\treturn buf->data[i] - prefix[i];\n\t}\n\n\treturn 0;\n}\n\n/* bufgrow: increasing the allocated size to the given value */\nint\nbufgrow(struct buf *buf, size_t neosz)\n{\n\tsize_t neoasz;\n\tvoid *neodata;\n\n\tassert(buf && buf->unit);\n\n\tif (neosz > BUFFER_MAX_ALLOC_SIZE)\n\t\treturn BUF_ENOMEM;\n\n\tif (buf->asize >= neosz)\n\t\treturn BUF_OK;\n\n\tneoasz = buf->asize + buf->unit;\n\twhile (neoasz < neosz)\n\t\tneoasz += buf->unit;\n\n\tneodata = realloc(buf->data, neoasz);\n\tif (!neodata)\n\t\treturn BUF_ENOMEM;\n\n\tbuf->data = neodata;\n\tbuf->asize = neoasz;\n\treturn BUF_OK;\n}\n\n\n/* bufnew: allocation of a new buffer */\nstruct buf *\nbufnew(size_t unit)\n{\n\tstruct buf *ret;\n\tret = malloc(sizeof (struct buf));\n\n\tif (ret) {\n\t\tret->data = 0;\n\t\tret->size = ret->asize = 0;\n\t\tret->unit = unit;\n\t}\n\treturn ret;\n}\n\n/* bufnullterm: NULL-termination of the string array */\nconst char *\nbufcstr(struct buf *buf)\n{\n\tassert(buf && buf->unit);\n\n\tif (buf->size < buf->asize && buf->data[buf->size] == 0)\n\t\treturn (char *)buf->data;\n\n\tif (buf->size + 1 <= buf->asize || bufgrow(buf, buf->size + 1) == 0) {\n\t\tbuf->data[buf->size] = 0;\n\t\treturn (char *)buf->data;\n\t}\n\n\treturn NULL;\n}\n\n/* bufprintf: formatted printing to a buffer */\nvoid\nbufprintf(struct buf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint n;\n\n\tassert(buf && buf->unit);\n\n\tif (buf->size >= buf->asize && bufgrow(buf, buf->size + 1) < 0)\n\t\treturn;\n\t\n\tva_start(ap, fmt);\n\tn = _buf_vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n\tva_end(ap);\n\n\tif (n < 0) {\n#ifdef _MSC_VER\n\t\tva_start(ap, fmt);\n\t\tn = _vscprintf(fmt, ap);\n\t\tva_end(ap);\n#else\n\t\treturn;\n#endif\n\t}\n\n\tif ((size_t)n >= buf->asize - buf->size) {\n\t\tif (bufgrow(buf, buf->size + n + 1) < 0)\n\t\t\treturn;\n\n\t\tva_start(ap, fmt);\n\t\tn = _buf_vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n\t\tva_end(ap);\n\t}\n\n\tif (n < 0)\n\t\treturn;\n\n\tbuf->size += n;\n}\n\n/* bufput: appends raw data to a buffer */\nvoid\nbufput(struct buf *buf, const void *data, size_t len)\n{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + len > buf->asize && bufgrow(buf, buf->size + len) < 0)\n\t\treturn;\n\n\tmemcpy(buf->data + buf->size, data, len);\n\tbuf->size += len;\n}\n\n/* bufputs: appends a NUL-terminated string to a buffer */\nvoid\nbufputs(struct buf *buf, const char *str)\n{\n\tbufput(buf, str, strlen(str));\n}\n\n\n/* bufputc: appends a single uint8_t to a buffer */\nvoid\nbufputc(struct buf *buf, int c)\n{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + 1 > buf->asize && bufgrow(buf, buf->size + 1) < 0)\n\t\treturn;\n\n\tbuf->data[buf->size] = c;\n\tbuf->size += 1;\n}\n\n/* bufrelease: decrease the reference count and free the buffer if needed */\nvoid\nbufrelease(struct buf *buf)\n{\n\tif (!buf)\n\t\treturn;\n\n\tfree(buf->data);\n\tfree(buf);\n}\n\n\n/* bufreset: frees internal data of the buffer */\nvoid\nbufreset(struct buf *buf)\n{\n\tif (!buf)\n\t\treturn;\n\n\tfree(buf->data);\n\tbuf->data = NULL;\n\tbuf->size = buf->asize = 0;\n}\n\n/* bufslurp: removes a given number of bytes from the head of the array */\nvoid\nbufslurp(struct buf *buf, size_t len)\n{\n\tassert(buf && buf->unit);\n\n\tif (len >= buf->size) {\n\t\tbuf->size = 0;\n\t\treturn;\n\t}\n\n\tbuf->size -= len;\n\tmemmove(buf->data, buf->data + len, buf->size);\n}\n\n","/*\n * Copyright (c) 2011, Vicent Marti\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"buffer.h\"\n#include \"autolink.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#if defined(_WIN32)\n#define strncasecmp\t_strnicmp\n#endif\n\nint\nsd_autolink_issafe(const uint8_t *link, size_t link_len)\n{\n\tstatic const size_t valid_uris_count = 5;\n\tstatic const char *valid_uris[] = {\n\t\t\"/\", \"http://\", \"https://\", \"ftp://\", \"mailto:\"\n\t};\n\n\tsize_t i;\n\n\tfor (i = 0; i < valid_uris_count; ++i) {\n\t\tsize_t len = strlen(valid_uris[i]);\n\n\t\tif (link_len > len &&\n\t\t\tstrncasecmp((char *)link, valid_uris[i], len) == 0 &&\n\t\t\tisalnum(link[len]))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic size_t\nautolink_delim(uint8_t *data, size_t link_end, size_t max_rewind, size_t size)\n{\n\tuint8_t cclose, copen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < link_end; ++i)\n\t\tif (data[i] == '<') {\n\t\t\tlink_end = i;\n\t\t\tbreak;\n\t\t}\n\n\twhile (link_end > 0) {\n\t\tif (strchr(\"?!.,\", data[link_end - 1]) != NULL)\n\t\t\tlink_end--;\n\n\t\telse if (data[link_end - 1] == ';') {\n\t\t\tsize_t new_end = link_end - 2;\n\n\t\t\twhile (new_end > 0 && isalpha(data[new_end]))\n\t\t\t\tnew_end--;\n\n\t\t\tif (new_end < link_end - 2 && data[new_end] == '&')\n\t\t\t\tlink_end = new_end;\n\t\t\telse\n\t\t\t\tlink_end--;\n\t\t}\n\t\telse break;\n\t}\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\tcclose = data[link_end - 1];\n\n\tswitch (cclose) {\n\tcase '\"':\tcopen = '\"'; break;\n\tcase '\\'':\tcopen = '\\''; break;\n\tcase ')':\tcopen = '('; break;\n\tcase ']':\tcopen = '['; break;\n\tcase '}':\tcopen = '{'; break;\n\t}\n\n\tif (copen != 0) {\n\t\tsize_t closing = 0;\n\t\tsize_t opening = 0;\n\t\tsize_t i = 0;\n\n\t\t/* Try to close the final punctuation sign in this same line;\n\t\t * if we managed to close it outside of the URL, that means that it's\n\t\t * not part of the URL. If it closes inside the URL, that means it\n\t\t * is part of the URL.\n\t\t *\n\t\t * Examples:\n\t\t *\n\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *\tfoo (http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric))\n\t\t *\n\t\t *\t(foo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> foo http://www.pokemon.com/Pikachu_(Electric)\n\t\t */\n\n\t\twhile (i < link_end) {\n\t\t\tif (data[i] == copen)\n\t\t\t\topening++;\n\t\t\telse if (data[i] == cclose)\n\t\t\t\tclosing++;\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (closing != opening)\n\t\t\tlink_end--;\n\t}\n\n\treturn link_end;\n}\n\nstatic size_t\ncheck_domain(uint8_t *data, size_t size, int allow_short)\n{\n\tsize_t i, np = 0;\n\n\tif (!isalnum(data[0]))\n\t\treturn 0;\n\n\tfor (i = 1; i < size - 1; ++i) {\n\t\tif (data[i] == '.') np++;\n\t\telse if (!isalnum(data[i]) && data[i] != '-') break;\n\t}\n\n\tif (allow_short) {\n\t\t/* We don't need a valid domain in the strict sense (with\n\t\t * least one dot; so just make sure it's composed of valid\n\t\t * domain characters and return the length of the the valid\n\t\t * sequence. */\n\t\treturn i;\n\t} else {\n\t\t/* a valid domain needs to have at least a dot.\n\t\t * that's as far as we get */\n\t\treturn np ? i : 0;\n\t}\n}\n\nsize_t\nsd_autolink__www(\n\tsize_t *rewind_p,\n\tstruct buf *link,\n\tuint8_t *data,\n\tsize_t max_rewind,\n\tsize_t size,\n\tunsigned int flags)\n{\n\tsize_t link_end;\n\n\tif (max_rewind > 0 && !ispunct(data[-1]) && !isspace(data[-1]))\n\t\treturn 0;\n\n\tif (size < 4 || memcmp(data, \"www.\", strlen(\"www.\")) != 0)\n\t\treturn 0;\n\n\tlink_end = check_domain(data, size, 0);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\twhile (link_end < size && !isspace(data[link_end]))\n\t\tlink_end++;\n\n\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\tbufput(link, data, link_end);\n\t*rewind_p = 0;\n\n\treturn (int)link_end;\n}\n\nsize_t\nsd_autolink__email(\n\tsize_t *rewind_p,\n\tstruct buf *link,\n\tuint8_t *data,\n\tsize_t max_rewind,\n\tsize_t size,\n\tunsigned int flags)\n{\n\tsize_t link_end, rewind;\n\tint nb = 0, np = 0;\n\n\tfor (rewind = 0; rewind < max_rewind; ++rewind) {\n\t\tuint8_t c = data[-rewind - 1];\n\n\t\tif (isalnum(c))\n\t\t\tcontinue;\n\n\t\tif (strchr(\".+-_\", c) != NULL)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tif (rewind == 0)\n\t\treturn 0;\n\n\tfor (link_end = 0; link_end < size; ++link_end) {\n\t\tuint8_t c = data[link_end];\n\n\t\tif (isalnum(c))\n\t\t\tcontinue;\n\n\t\tif (c == '@')\n\t\t\tnb++;\n\t\telse if (c == '.' && link_end < size - 1)\n\t\t\tnp++;\n\t\telse if (c != '-' && c != '_')\n\t\t\tbreak;\n\t}\n\n\tif (link_end < 2 || nb != 1 || np == 0 ||\n\t\t!isalpha(data[link_end - 1]))\n\t\treturn 0;\n\n\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\tbufput(link, data - rewind, link_end + rewind);\n\t*rewind_p = rewind;\n\n\treturn link_end;\n}\n\nsize_t\nsd_autolink__url(\n\tsize_t *rewind_p,\n\tstruct buf *link,\n\tuint8_t *data,\n\tsize_t max_rewind,\n\tsize_t size,\n\tunsigned int flags)\n{\n\tsize_t link_end, rewind = 0, domain_len;\n\n\tif (size < 4 || data[1] != '/' || data[2] != '/')\n\t\treturn 0;\n\n\twhile (rewind < max_rewind && isalpha(data[-rewind - 1]))\n\t\trewind++;\n\n\tif (!sd_autolink_issafe(data - rewind, size + rewind))\n\t\treturn 0;\n\n\tlink_end = strlen(\"://\");\n\n\tdomain_len = check_domain(\n\t\tdata + link_end,\n\t\tsize - link_end,\n\t\tflags & SD_AUTOLINK_SHORT_DOMAINS);\n\n\tif (domain_len == 0)\n\t\treturn 0;\n\n\tlink_end += domain_len;\n\twhile (link_end < size && !isspace(data[link_end]))\n\t\tlink_end++;\n\n\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\tbufput(link, data - rewind, link_end + rewind);\n\t*rewind_p = rewind;\n\n\treturn link_end;\n}\n\n","/*\n * Copyright (c) 2013, Marc Heiligers\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"redcarpet_js.h\"\n#include <stdlib.h>\n\nstruct sd_callbacks* create_sd_callbacks() {\n  return malloc(sizeof(struct sd_callbacks));\n}\n\nstruct html_renderopt* create_html_renderopt() {\n  return malloc(sizeof(struct html_renderopt));\n}\n","/*\n * Copyright (c) 2009, Natacha Porté\n * Copyright (c) 2011, Vicent Marti\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"markdown.h\"\n#include \"html.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"houdini.h\"\n\n#define USE_XHTML(opt) (opt->flags & HTML_USE_XHTML)\n\nint\nsdhtml_is_tag(const uint8_t *tag_data, size_t tag_size, const char *tagname)\n{\n\tsize_t i;\n\tint closed = 0;\n\n\tif (tag_size < 3 || tag_data[0] != '<')\n\t\treturn HTML_TAG_NONE;\n\n\ti = 1;\n\n\tif (tag_data[i] == '/') {\n\t\tclosed = 1;\n\t\ti++;\n\t}\n\n\tfor (; i < tag_size; ++i, ++tagname) {\n\t\tif (*tagname == 0)\n\t\t\tbreak;\n\n\t\tif (tag_data[i] != *tagname)\n\t\t\treturn HTML_TAG_NONE;\n\t}\n\n\tif (i == tag_size)\n\t\treturn HTML_TAG_NONE;\n\n\tif (isspace(tag_data[i]) || tag_data[i] == '>')\n\t\treturn closed ? HTML_TAG_CLOSE : HTML_TAG_OPEN;\n\n\treturn HTML_TAG_NONE;\n}\n\nstatic inline void escape_html(struct buf *ob, const uint8_t *source, size_t length)\n{\n\thoudini_escape_html0(ob, source, length, 0);\n}\n\nstatic inline void escape_href(struct buf *ob, const uint8_t *source, size_t length)\n{\n\thoudini_escape_href(ob, source, length);\n}\n\n/********************\n * GENERIC RENDERER *\n ********************/\nstatic int\nrndr_autolink(struct buf *ob, const struct buf *link, enum mkd_autolink type, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\n\tif (!link || !link->size)\n\t\treturn 0;\n\n\tif ((options->flags & HTML_SAFELINK) != 0 &&\n\t\t!sd_autolink_issafe(link->data, link->size) &&\n\t\ttype != MKDA_EMAIL)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<a href=\\\"\");\n\tif (type == MKDA_EMAIL)\n\t\tBUFPUTSL(ob, \"mailto:\");\n\tescape_href(ob, link->data, link->size);\n\n\tif (options->link_attributes) {\n\t\tbufputc(ob, '\\\"');\n\t\toptions->link_attributes(ob, link, opaque);\n\t\tbufputc(ob, '>');\n\t} else {\n\t\tBUFPUTSL(ob, \"\\\">\");\n\t}\n\n\t/*\n\t * Pretty printing: if we get an email address as\n\t * an actual URI, e.g. `mailto:foo@bar.com`, we don't\n\t * want to print the `mailto:` prefix\n\t */\n\tif (bufprefix(link, \"mailto:\") == 0) {\n\t\tescape_html(ob, link->data + 7, link->size - 7);\n\t} else {\n\t\tescape_html(ob, link->data, link->size);\n\t}\n\n\tBUFPUTSL(ob, \"</a>\");\n\n\treturn 1;\n}\n\nstatic void\nrndr_blockcode(struct buf *ob, const struct buf *text, const struct buf *lang, void *opaque)\n{\n\tif (ob->size) bufputc(ob, '\\n');\n\n\tif (lang && lang->size) {\n\t\tsize_t i, cls;\n\t\tBUFPUTSL(ob, \"<pre><code class=\\\"\");\n\n\t\tfor (i = 0, cls = 0; i < lang->size; ++i, ++cls) {\n\t\t\twhile (i < lang->size && isspace(lang->data[i]))\n\t\t\t\ti++;\n\n\t\t\tif (i < lang->size) {\n\t\t\t\tsize_t org = i;\n\t\t\t\twhile (i < lang->size && !isspace(lang->data[i]))\n\t\t\t\t\ti++;\n\n\t\t\t\tif (lang->data[org] == '.')\n\t\t\t\t\torg++;\n\n\t\t\t\tif (cls) bufputc(ob, ' ');\n\t\t\t\tescape_html(ob, lang->data + org, i - org);\n\t\t\t}\n\t\t}\n\n\t\tBUFPUTSL(ob, \"\\\">\");\n\t} else\n\t\tBUFPUTSL(ob, \"<pre><code>\");\n\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\n\tBUFPUTSL(ob, \"</code></pre>\\n\");\n}\n\nstatic void\nrndr_blockquote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (ob->size) bufputc(ob, '\\n');\n\tBUFPUTSL(ob, \"<blockquote>\\n\");\n\tif (text) bufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</blockquote>\\n\");\n}\n\nstatic int\nrndr_codespan(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tBUFPUTSL(ob, \"<code>\");\n\tif (text) escape_html(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</code>\");\n\treturn 1;\n}\n\nstatic int\nrndr_strikethrough(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<del>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</del>\");\n\treturn 1;\n}\n\nstatic int\nrndr_double_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<strong>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</strong>\");\n\n\treturn 1;\n}\n\nstatic int\nrndr_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size) return 0;\n\tBUFPUTSL(ob, \"<em>\");\n\tif (text) bufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</em>\");\n\treturn 1;\n}\n\nstatic int\nrndr_linebreak(struct buf *ob, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\tbufputs(ob, USE_XHTML(options) ? \"<br/>\\n\" : \"<br>\\n\");\n\treturn 1;\n}\n\nstatic void\nrndr_header(struct buf *ob, const struct buf *text, int level, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\n\tif (ob->size)\n\t\tbufputc(ob, '\\n');\n\n\tif (options->flags & HTML_TOC)\n\t\tbufprintf(ob, \"<h%d id=\\\"toc_%d\\\">\", level, options->toc_data.header_count++);\n\telse\n\t\tbufprintf(ob, \"<h%d>\", level);\n\n\tif (text) bufput(ob, text->data, text->size);\n\tbufprintf(ob, \"</h%d>\\n\", level);\n}\n\nstatic int\nrndr_link(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\n\tif (link != NULL && (options->flags & HTML_SAFELINK) != 0 && !sd_autolink_issafe(link->data, link->size))\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<a href=\\\"\");\n\n\tif (link && link->size)\n\t\tescape_href(ob, link->data, link->size);\n\n\tif (title && title->size) {\n\t\tBUFPUTSL(ob, \"\\\" title=\\\"\");\n\t\tescape_html(ob, title->data, title->size);\n\t}\n\n\tif (options->link_attributes) {\n\t\tbufputc(ob, '\\\"');\n\t\toptions->link_attributes(ob, link, opaque);\n\t\tbufputc(ob, '>');\n\t} else {\n\t\tBUFPUTSL(ob, \"\\\">\");\n\t}\n\n\tif (content && content->size) bufput(ob, content->data, content->size);\n\tBUFPUTSL(ob, \"</a>\");\n\treturn 1;\n}\n\nstatic void\nrndr_list(struct buf *ob, const struct buf *text, int flags, void *opaque)\n{\n\tif (ob->size) bufputc(ob, '\\n');\n\tbufput(ob, flags & MKD_LIST_ORDERED ? \"<ol>\\n\" : \"<ul>\\n\", 5);\n\tif (text) bufput(ob, text->data, text->size);\n\tbufput(ob, flags & MKD_LIST_ORDERED ? \"</ol>\\n\" : \"</ul>\\n\", 6);\n}\n\nstatic void\nrndr_listitem(struct buf *ob, const struct buf *text, int flags, void *opaque)\n{\n\tBUFPUTSL(ob, \"<li>\");\n\tif (text) {\n\t\tsize_t size = text->size;\n\t\twhile (size && text->data[size - 1] == '\\n')\n\t\t\tsize--;\n\n\t\tbufput(ob, text->data, size);\n\t}\n\tBUFPUTSL(ob, \"</li>\\n\");\n}\n\nstatic void\nrndr_paragraph(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\tsize_t i = 0;\n\n\tif (ob->size) bufputc(ob, '\\n');\n\n\tif (!text || !text->size)\n\t\treturn;\n\n\twhile (i < text->size && isspace(text->data[i])) i++;\n\n\tif (i == text->size)\n\t\treturn;\n\n\tBUFPUTSL(ob, \"<p>\");\n\tif (options->flags & HTML_HARD_WRAP) {\n\t\tsize_t org;\n\t\twhile (i < text->size) {\n\t\t\torg = i;\n\t\t\twhile (i < text->size && text->data[i] != '\\n')\n\t\t\t\ti++;\n\n\t\t\tif (i > org)\n\t\t\t\tbufput(ob, text->data + org, i - org);\n\n\t\t\t/*\n\t\t\t * do not insert a line break if this newline\n\t\t\t * is the last character on the paragraph\n\t\t\t */\n\t\t\tif (i >= text->size - 1)\n\t\t\t\tbreak;\n\n\t\t\trndr_linebreak(ob, opaque);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tbufput(ob, &text->data[i], text->size - i);\n\t}\n\tBUFPUTSL(ob, \"</p>\\n\");\n}\n\nstatic void\nrndr_raw_block(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tsize_t org, sz;\n\tif (!text) return;\n\tsz = text->size;\n\twhile (sz > 0 && text->data[sz - 1] == '\\n') sz--;\n\torg = 0;\n\twhile (org < sz && text->data[org] == '\\n') org++;\n\tif (org >= sz) return;\n\tif (ob->size) bufputc(ob, '\\n');\n\tbufput(ob, text->data + org, sz - org);\n\tbufputc(ob, '\\n');\n}\n\nstatic int\nrndr_triple_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size) return 0;\n\tBUFPUTSL(ob, \"<strong><em>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</em></strong>\");\n\treturn 1;\n}\n\nstatic void\nrndr_hrule(struct buf *ob, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\tif (ob->size) bufputc(ob, '\\n');\n\tbufputs(ob, USE_XHTML(options) ? \"<hr/>\\n\" : \"<hr>\\n\");\n}\n\nstatic int\nrndr_image(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *alt, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\tif (!link || !link->size) return 0;\n\n\tBUFPUTSL(ob, \"<img src=\\\"\");\n\tescape_href(ob, link->data, link->size);\n\tBUFPUTSL(ob, \"\\\" alt=\\\"\");\n\n\tif (alt && alt->size)\n\t\tescape_html(ob, alt->data, alt->size);\n\n\tif (title && title->size) {\n\t\tBUFPUTSL(ob, \"\\\" title=\\\"\");\n\t\tescape_html(ob, title->data, title->size); }\n\n\tbufputs(ob, USE_XHTML(options) ? \"\\\"/>\" : \"\\\">\");\n\treturn 1;\n}\n\nstatic int\nrndr_raw_html(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\n\t/* HTML_ESCAPE overrides SKIP_HTML, SKIP_STYLE, SKIP_LINKS and SKIP_IMAGES\n\t* It doens't see if there are any valid tags, just escape all of them. */\n\tif((options->flags & HTML_ESCAPE) != 0) {\n\t\tescape_html(ob, text->data, text->size);\n\t\treturn 1;\n\t}\n\n\tif ((options->flags & HTML_SKIP_HTML) != 0)\n\t\treturn 1;\n\n\tif ((options->flags & HTML_SKIP_STYLE) != 0 &&\n\t\tsdhtml_is_tag(text->data, text->size, \"style\"))\n\t\treturn 1;\n\n\tif ((options->flags & HTML_SKIP_LINKS) != 0 &&\n\t\tsdhtml_is_tag(text->data, text->size, \"a\"))\n\t\treturn 1;\n\n\tif ((options->flags & HTML_SKIP_IMAGES) != 0 &&\n\t\tsdhtml_is_tag(text->data, text->size, \"img\"))\n\t\treturn 1;\n\n\tbufput(ob, text->data, text->size);\n\treturn 1;\n}\n\nstatic void\nrndr_table(struct buf *ob, const struct buf *header, const struct buf *body, void *opaque)\n{\n\tif (ob->size) bufputc(ob, '\\n');\n\tBUFPUTSL(ob, \"<table><thead>\\n\");\n\tif (header)\n\t\tbufput(ob, header->data, header->size);\n\tBUFPUTSL(ob, \"</thead><tbody>\\n\");\n\tif (body)\n\t\tbufput(ob, body->data, body->size);\n\tBUFPUTSL(ob, \"</tbody></table>\\n\");\n}\n\nstatic void\nrndr_tablerow(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tBUFPUTSL(ob, \"<tr>\\n\");\n\tif (text)\n\t\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</tr>\\n\");\n}\n\nstatic void\nrndr_tablecell(struct buf *ob, const struct buf *text, int flags, void *opaque)\n{\n\tif (flags & MKD_TABLE_HEADER) {\n\t\tBUFPUTSL(ob, \"<th\");\n\t} else {\n\t\tBUFPUTSL(ob, \"<td\");\n\t}\n\n\tswitch (flags & MKD_TABLE_ALIGNMASK) {\n\tcase MKD_TABLE_ALIGN_CENTER:\n\t\tBUFPUTSL(ob, \" align=\\\"center\\\">\");\n\t\tbreak;\n\n\tcase MKD_TABLE_ALIGN_L:\n\t\tBUFPUTSL(ob, \" align=\\\"left\\\">\");\n\t\tbreak;\n\n\tcase MKD_TABLE_ALIGN_R:\n\t\tBUFPUTSL(ob, \" align=\\\"right\\\">\");\n\t\tbreak;\n\n\tdefault:\n\t\tBUFPUTSL(ob, \">\");\n\t}\n\n\tif (text)\n\t\tbufput(ob, text->data, text->size);\n\n\tif (flags & MKD_TABLE_HEADER) {\n\t\tBUFPUTSL(ob, \"</th>\\n\");\n\t} else {\n\t\tBUFPUTSL(ob, \"</td>\\n\");\n\t}\n}\n\nstatic int\nrndr_superscript(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size) return 0;\n\tBUFPUTSL(ob, \"<sup>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</sup>\");\n\treturn 1;\n}\n\nstatic void\nrndr_normal_text(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n}\n\nstatic void\ntoc_header(struct buf *ob, const struct buf *text, int level, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\n\t/* set the level offset if this is the first header\n\t * we're parsing for the document */\n\tif (options->toc_data.current_level == 0) {\n\t\toptions->toc_data.level_offset = level - 1;\n\t}\n\tlevel -= options->toc_data.level_offset;\n\n\tif (level > options->toc_data.current_level) {\n\t\twhile (level > options->toc_data.current_level) {\n\t\t\tBUFPUTSL(ob, \"<ul>\\n<li>\\n\");\n\t\t\toptions->toc_data.current_level++;\n\t\t}\n\t} else if (level < options->toc_data.current_level) {\n\t\tBUFPUTSL(ob, \"</li>\\n\");\n\t\twhile (level < options->toc_data.current_level) {\n\t\t\tBUFPUTSL(ob, \"</ul>\\n</li>\\n\");\n\t\t\toptions->toc_data.current_level--;\n\t\t}\n\t\tBUFPUTSL(ob,\"<li>\\n\");\n\t} else {\n\t\tBUFPUTSL(ob,\"</li>\\n<li>\\n\");\n\t}\n\n\tbufprintf(ob, \"<a href=\\\"#toc_%d\\\">\", options->toc_data.header_count++);\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</a>\\n\");\n}\n\nstatic int\ntoc_link(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque)\n{\n\tif (content && content->size)\n\t\tbufput(ob, content->data, content->size);\n\treturn 1;\n}\n\nstatic void\ntoc_finalize(struct buf *ob, void *opaque)\n{\n\tstruct html_renderopt *options = opaque;\n\n\twhile (options->toc_data.current_level > 0) {\n\t\tBUFPUTSL(ob, \"</li>\\n</ul>\\n\");\n\t\toptions->toc_data.current_level--;\n\t}\n}\n\nvoid\nsdhtml_toc_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options)\n{\n\tstatic const struct sd_callbacks cb_default = {\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\ttoc_header,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\n\t\tNULL,\n\t\trndr_codespan,\n\t\trndr_double_emphasis,\n\t\trndr_emphasis,\n\t\tNULL,\n\t\tNULL,\n\t\ttoc_link,\n\t\tNULL,\n\t\trndr_triple_emphasis,\n\t\trndr_strikethrough,\n\t\trndr_superscript,\n\n\t\tNULL,\n\t\tNULL,\n\n\t\tNULL,\n\t\ttoc_finalize,\n\t};\n\n\tmemset(options, 0x0, sizeof(struct html_renderopt));\n\toptions->flags = HTML_TOC;\n\n\tmemcpy(callbacks, &cb_default, sizeof(struct sd_callbacks));\n}\n\nvoid\nsdhtml_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options, unsigned int render_flags)\n{\n\tstatic const struct sd_callbacks cb_default = {\n\t\trndr_blockcode,\n\t\trndr_blockquote,\n\t\trndr_raw_block,\n\t\trndr_header,\n\t\trndr_hrule,\n\t\trndr_list,\n\t\trndr_listitem,\n\t\trndr_paragraph,\n\t\trndr_table,\n\t\trndr_tablerow,\n\t\trndr_tablecell,\n\n\t\trndr_autolink,\n\t\trndr_codespan,\n\t\trndr_double_emphasis,\n\t\trndr_emphasis,\n\t\trndr_image,\n\t\trndr_linebreak,\n\t\trndr_link,\n\t\trndr_raw_html,\n\t\trndr_triple_emphasis,\n\t\trndr_strikethrough,\n\t\trndr_superscript,\n\n\t\tNULL,\n\t\trndr_normal_text,\n\n\t\tNULL,\n\t\tNULL,\n\t};\n\n\t/* Prepare the options pointer */\n\tmemset(options, 0x0, sizeof(struct html_renderopt));\n\toptions->flags = render_flags;\n\n\t/* Prepare the callbacks */\n\tmemcpy(callbacks, &cb_default, sizeof(struct sd_callbacks));\n\n\tif (render_flags & HTML_SKIP_IMAGES)\n\t\tcallbacks->image = NULL;\n\n\tif (render_flags & HTML_SKIP_LINKS) {\n\t\tcallbacks->link = NULL;\n\t\tcallbacks->autolink = NULL;\n\t}\n\n\tif (render_flags & HTML_SKIP_HTML || render_flags & HTML_ESCAPE)\n\t\tcallbacks->blockhtml = NULL;\n}\n","/*\n * Copyright (c) 2011, Vicent Marti\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"buffer.h\"\n#include \"html.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#if defined(_WIN32)\n#define snprintf\t_snprintf\t\t\n#endif\n\nstruct smartypants_data {\n\tint in_squote;\n\tint in_dquote;\n};\n\nstatic size_t smartypants_cb__ltag(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__dquote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__amp(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__period(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__parens(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__squote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__escape(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n\nstatic size_t (*smartypants_cb_ptrs[])\n\t(struct buf *, struct smartypants_data *, uint8_t, const uint8_t *, size_t) =\n{\n\tNULL,\t\t\t\t\t/* 0 */\n\tsmartypants_cb__dash,\t/* 1 */\n\tsmartypants_cb__parens,\t/* 2 */\n\tsmartypants_cb__squote, /* 3 */\n\tsmartypants_cb__dquote, /* 4 */\n\tsmartypants_cb__amp,\t/* 5 */\n\tsmartypants_cb__period,\t/* 6 */\n\tsmartypants_cb__number,\t/* 7 */\n\tsmartypants_cb__ltag,\t/* 8 */\n\tsmartypants_cb__backtick, /* 9 */\n\tsmartypants_cb__escape, /* 10 */\n};\n\nstatic const uint8_t smartypants_cb_chars[] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 4, 0, 0, 0, 5, 3, 2, 0, 0, 0, 0, 1, 6, 0,\n\t0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,\n\t9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic inline int\nword_boundary(uint8_t c)\n{\n\treturn c == 0 || isspace(c) || ispunct(c);\n}\n\nstatic int\nsmartypants_quotes(struct buf *ob, uint8_t previous_char, uint8_t next_char, uint8_t quote, int *is_open)\n{\n\tchar ent[8];\n\n\tif (*is_open && !word_boundary(next_char))\n\t\treturn 0;\n\n\tif (!(*is_open) && !word_boundary(previous_char))\n\t\treturn 0;\n\n\tsnprintf(ent, sizeof(ent), \"&%c%cquo;\", (*is_open) ? 'r' : 'l', quote);\n\t*is_open = !(*is_open);\n\tbufputs(ob, ent);\n\treturn 1;\n}\n\nstatic size_t\nsmartypants_cb__squote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 2) {\n\t\tuint8_t t1 = tolower(text[1]);\n\n\t\tif (t1 == '\\'') {\n\t\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tif ((t1 == 's' || t1 == 't' || t1 == 'm' || t1 == 'd') &&\n\t\t\t(size == 3 || word_boundary(text[2]))) {\n\t\t\tBUFPUTSL(ob, \"&rsquo;\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (size >= 3) {\n\t\t\tuint8_t t2 = tolower(text[2]);\n\n\t\t\tif (((t1 == 'r' && t2 == 'e') ||\n\t\t\t\t(t1 == 'l' && t2 == 'l') ||\n\t\t\t\t(t1 == 'v' && t2 == 'e')) &&\n\t\t\t\t(size == 4 || word_boundary(text[3]))) {\n\t\t\t\tBUFPUTSL(ob, \"&rsquo;\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 's', &smrt->in_squote))\n\t\treturn 0;\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__parens(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 3) {\n\t\tuint8_t t1 = tolower(text[1]);\n\t\tuint8_t t2 = tolower(text[2]);\n\n\t\tif (t1 == 'c' && t2 == ')') {\n\t\t\tBUFPUTSL(ob, \"&copy;\");\n\t\t\treturn 2;\n\t\t}\n\n\t\tif (t1 == 'r' && t2 == ')') {\n\t\t\tBUFPUTSL(ob, \"&reg;\");\n\t\t\treturn 2;\n\t\t}\n\n\t\tif (size >= 4 && t1 == 't' && t2 == 'm' && text[3] == ')') {\n\t\t\tBUFPUTSL(ob, \"&trade;\");\n\t\t\treturn 3;\n\t\t}\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 3 && text[1] == '-' && text[2] == '-') {\n\t\tBUFPUTSL(ob, \"&mdash;\");\n\t\treturn 2;\n\t}\n\n\tif (size >= 2 && text[1] == '-') {\n\t\tBUFPUTSL(ob, \"&ndash;\");\n\t\treturn 1;\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__amp(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 6 && memcmp(text, \"&quot;\", 6) == 0) {\n\t\tif (smartypants_quotes(ob, previous_char, size >= 7 ? text[6] : 0, 'd', &smrt->in_dquote))\n\t\t\treturn 5;\n\t}\n\n\tif (size >= 4 && memcmp(text, \"&#0;\", 4) == 0)\n\t\treturn 3;\n\n\tbufputc(ob, '&');\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__period(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 3 && text[1] == '.' && text[2] == '.') {\n\t\tBUFPUTSL(ob, \"&hellip;\");\n\t\treturn 2;\n\t}\n\n\tif (size >= 5 && text[1] == ' ' && text[2] == '.' && text[3] == ' ' && text[4] == '.') {\n\t\tBUFPUTSL(ob, \"&hellip;\");\n\t\treturn 4;\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 2 && text[1] == '`') {\n\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (word_boundary(previous_char) && size >= 3) {\n\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '2') {\n\t\t\tif (size == 3 || word_boundary(text[3])) {\n\t\t\t\tBUFPUTSL(ob, \"&frac12;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '4') {\n\t\t\tif (size == 3 || word_boundary(text[3]) ||\n\t\t\t\t(size >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h')) {\n\t\t\t\tBUFPUTSL(ob, \"&frac14;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (text[0] == '3' && text[1] == '/' && text[2] == '4') {\n\t\t\tif (size == 3 || word_boundary(text[3]) ||\n\t\t\t\t(size >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's')) {\n\t\t\t\tBUFPUTSL(ob, \"&frac34;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tbufputc(ob, text[0]);\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__dquote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (!smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 'd', &smrt->in_dquote))\n\t\tBUFPUTSL(ob, \"&quot;\");\n\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__ltag(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tstatic const char *skip_tags[] = {\n\t  \"pre\", \"code\", \"var\", \"samp\", \"kbd\", \"math\", \"script\", \"style\"\n\t};\n\tstatic const size_t skip_tags_count = 8;\n\n\tsize_t tag, i = 0;\n\n\twhile (i < size && text[i] != '>')\n\t\ti++;\n\n\tfor (tag = 0; tag < skip_tags_count; ++tag) {\n\t\tif (sdhtml_is_tag(text, size, skip_tags[tag]) == HTML_TAG_OPEN)\n\t\t\tbreak;\n\t}\n\n\tif (tag < skip_tags_count) {\n\t\tfor (;;) {\n\t\t\twhile (i < size && text[i] != '<')\n\t\t\t\ti++;\n\n\t\t\tif (i == size)\n\t\t\t\tbreak;\n\n\t\t\tif (sdhtml_is_tag(text + i, size - i, skip_tags[tag]) == HTML_TAG_CLOSE)\n\t\t\t\tbreak;\n\n\t\t\ti++;\n\t\t}\n\n\t\twhile (i < size && text[i] != '>')\n\t\t\ti++;\n\t}\n\n\tbufput(ob, text, i + 1);\n\treturn i;\n}\n\nstatic size_t\nsmartypants_cb__escape(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size < 2)\n\t\treturn 0;\n\n\tswitch (text[1]) {\n\tcase '\\\\':\n\tcase '\"':\n\tcase '\\'':\n\tcase '.':\n\tcase '-':\n\tcase '`':\n\t\tbufputc(ob, text[1]);\n\t\treturn 1;\n\n\tdefault:\n\t\tbufputc(ob, '\\\\');\n\t\treturn 0;\n\t}\n}\n\n#if 0\nstatic struct {\n    uint8_t c0;\n    const uint8_t *pattern;\n    const uint8_t *entity;\n    int skip;\n} smartypants_subs[] = {\n    { '\\'', \"'s>\",      \"&rsquo;\",  0 },\n    { '\\'', \"'t>\",      \"&rsquo;\",  0 },\n    { '\\'', \"'re>\",     \"&rsquo;\",  0 },\n    { '\\'', \"'ll>\",     \"&rsquo;\",  0 },\n    { '\\'', \"'ve>\",     \"&rsquo;\",  0 },\n    { '\\'', \"'m>\",      \"&rsquo;\",  0 },\n    { '\\'', \"'d>\",      \"&rsquo;\",  0 },\n    { '-',  \"--\",       \"&mdash;\",  1 },\n    { '-',  \"<->\",      \"&ndash;\",  0 },\n    { '.',  \"...\",      \"&hellip;\", 2 },\n    { '.',  \". . .\",    \"&hellip;\", 4 },\n    { '(',  \"(c)\",      \"&copy;\",   2 },\n    { '(',  \"(r)\",      \"&reg;\",    2 },\n    { '(',  \"(tm)\",     \"&trade;\",  3 },\n    { '3',  \"<3/4>\",    \"&frac34;\", 2 },\n    { '3',  \"<3/4ths>\", \"&frac34;\", 2 },\n    { '1',  \"<1/2>\",    \"&frac12;\", 2 },\n    { '1',  \"<1/4>\",    \"&frac14;\", 2 },\n    { '1',  \"<1/4th>\",  \"&frac14;\", 2 },\n    { '&',  \"&#0;\",      0,       3 },\n};\n#endif\n\nvoid\nsdhtml_smartypants(struct buf *ob, const uint8_t *text, size_t size)\n{\n\tsize_t i;\n\tstruct smartypants_data smrt = {0, 0};\n\n\tif (!text)\n\t\treturn;\n\n\tbufgrow(ob, size);\n\n\tfor (i = 0; i < size; ++i) {\n\t\tsize_t org;\n\t\tuint8_t action = 0;\n\n\t\torg = i;\n\t\twhile (i < size && (action = smartypants_cb_chars[text[i]]) == 0)\n\t\t\ti++;\n\n\t\tif (i > org)\n\t\t\tbufput(ob, text + org, i - org);\n\n\t\tif (i < size) {\n\t\t\ti += smartypants_cb_ptrs[(int)action]\n\t\t\t\t(ob, &smrt, i ? text[i - 1] : 0, text + i, size - i);\n\t\t}\n\t}\n}\n\n\n","#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"houdini.h\"\n\n#define ESCAPE_GROW_FACTOR(x) (((x) * 12) / 10) /* this is very scientific, yes */\n\n/**\n * According to the OWASP rules:\n *\n * & --> &amp;\n * < --> &lt;\n * > --> &gt;\n * \" --> &quot;\n * ' --> &#x27;     &apos; is not recommended\n * / --> &#x2F;     forward slash is included as it helps end an HTML entity\n *\n */\nstatic const char HTML_ESCAPE_TABLE[] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 1, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 4, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic const char *HTML_ESCAPES[] = {\n        \"\",\n        \"&quot;\",\n        \"&amp;\",\n        \"&#39;\",\n        \"&#47;\",\n        \"&lt;\",\n        \"&gt;\"\n};\n\nvoid\nhoudini_escape_html0(struct buf *ob, const uint8_t *src, size_t size, int secure)\n{\n\tsize_t i = 0, org, esc = 0;\n\n\tbufgrow(ob, ESCAPE_GROW_FACTOR(size));\n\n\twhile (i < size) {\n\t\torg = i;\n\t\twhile (i < size && (esc = HTML_ESCAPE_TABLE[src[i]]) == 0)\n\t\t\ti++;\n\n\t\tif (i > org)\n\t\t\tbufput(ob, src + org, i - org);\n\n\t\t/* escaping */\n\t\tif (i >= size)\n\t\t\tbreak;\n\n\t\t/* The forward slash is only escaped in secure mode */\n\t\tif (src[i] == '/' && !secure) {\n\t\t\tbufputc(ob, '/');\n\t\t} else {\n\t\t\tbufputs(ob, HTML_ESCAPES[esc]);\n\t\t}\n\n\t\ti++;\n\t}\n}\n\nvoid\nhoudini_escape_html(struct buf *ob, const uint8_t *src, size_t size)\n{\n\thoudini_escape_html0(ob, src, size, 1);\n}\n\n","#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"houdini.h\"\n\n#define ESCAPE_GROW_FACTOR(x) (((x) * 12) / 10)\n\n/*\n * The following characters will not be escaped:\n *\n *\t\t-_.+!*'(),%#@?=;:/,+&$ alphanum\n *\n * Note that this character set is the addition of:\n *\n *\t- The characters which are safe to be in an URL\n *\t- The characters which are *not* safe to be in\n *\tan URL because they are RESERVED characters.\n *\n * We asume (lazily) that any RESERVED char that\n * appears inside an URL is actually meant to\n * have its native function (i.e. as an URL \n * component/separator) and hence needs no escaping.\n *\n * There are two exceptions: the chacters & (amp)\n * and ' (single quote) do not appear in the table.\n * They are meant to appear in the URL as components,\n * yet they require special HTML-entity escaping\n * to generate valid HTML markup.\n *\n * All other characters will be escaped to %XX.\n *\n */\nstatic const char HREF_SAFE[] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, \n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, \n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, \n\t0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nvoid\nhoudini_escape_href(struct buf *ob, const uint8_t *src, size_t size)\n{\n\tstatic const char hex_chars[] = \"0123456789ABCDEF\";\n\tsize_t  i = 0, org;\n\tchar hex_str[3];\n\n\tbufgrow(ob, ESCAPE_GROW_FACTOR(size));\n\thex_str[0] = '%';\n\n\twhile (i < size) {\n\t\torg = i;\n\t\twhile (i < size && HREF_SAFE[src[i]] != 0)\n\t\t\ti++;\n\n\t\tif (i > org)\n\t\t\tbufput(ob, src + org, i - org);\n\n\t\t/* escaping */\n\t\tif (i >= size)\n\t\t\tbreak;\n\n\t\tswitch (src[i]) {\n\t\t/* amp appears all the time in URLs, but needs\n\t\t * HTML-entity escaping to be inside an href */\n\t\tcase '&': \n\t\t\tBUFPUTSL(ob, \"&amp;\");\n\t\t\tbreak;\n\n\t\t/* the single quote is a valid URL character\n\t\t * according to the standard; it needs HTML\n\t\t * entity escaping too */\n\t\tcase '\\'':\n\t\t\tBUFPUTSL(ob, \"&#x27;\");\n\t\t\tbreak;\n\t\t\n\t\t/* the space can be escaped to %20 or a plus\n\t\t * sign. we're going with the generic escape\n\t\t * for now. the plus thing is more commonly seen\n\t\t * when building GET strings */\n#if 0\n\t\tcase ' ':\n\t\t\tbufputc(ob, '+');\n\t\t\tbreak;\n#endif\n\n\t\t/* every other character goes with a %XX escaping */\n\t\tdefault:\n\t\t\thex_str[1] = hex_chars[(src[i] >> 4) & 0xF];\n\t\t\thex_str[2] = hex_chars[src[i] & 0xF];\n\t\t\tbufput(ob, hex_str, 3);\n\t\t}\n\n\t\ti++;\n\t}\n}\n"]}